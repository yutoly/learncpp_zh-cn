16.5 — 返回std::vector与移动语义简介  
================================================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2025年1月10日（首次发布于2024年12月16日）  

当需要将`std::vector`传递给函数时，我们通过（常量）引用传递以避免复制数组数据的昂贵开销。  

但您可能会惊讶地发现：**按值返回`std::vector`是可行的**。  

什么？？？  

复制语义（copy semantics）  
----------------  

考虑以下程序：  

```cpp
#include <iostream>
#include <vector>

int main()
{
    std::vector arr1 { 1, 2, 3, 4, 5 }; // 将{1,2,3,4,5}复制到arr1
    std::vector arr2 { arr1 };            // 将arr1复制到arr2

    arr1[0] = 6; // 可继续使用arr1
    arr2[0] = 7; // 可继续使用arr2

    std::cout << arr1[0] << arr2[0] << '\n';

    return 0;
}
```  

当用`arr1`初始化`arr2`时，会调用`std::vector`的**复制构造函数（copy constructor）**，将`arr1`复制到`arr2`。  

此场景中复制是唯一合理的选择，因为`arr1`和`arr2`需独立存在。本例最终产生两次复制（每次初始化各一次）。  

**复制语义（copy semantics）**指决定对象复制方式的规则。若某类型支持复制语义，则其对象可被复制（因复制规则已定义）。当复制语义被调用时，意味着对象将被复制。  

对于类类型，复制语义通常通过**复制构造函数（copy constructor）**和**复制赋值运算符（copy assignment operator）**实现。这些函数定义了类数据成员的复制方式。上例中语句`std::vector arr2 { arr1 };`调用了复制语义，导致`std::vector`的复制构造函数将`arr1`的每个数据成员复制到`arr2`。最终`arr1`与`arr2`等价但相互独立。  

复制语义的非最优场景  
----------------  

现在考虑以下示例：  

```cpp
#include <iostream>
#include <vector>

std::vector<int> generate() // 按值返回
{
    // 此处故意使用具名对象以避免强制复制省略
    std::vector arr1 { 1, 2, 3, 4, 5 }; // 将{1,2,3,4,5}复制到arr1
    return arr1;
}

int main()
{
    std::vector arr2 { generate() }; // generate()的返回值在表达式结束时消亡

    // 此处无法使用generate()的返回值
    arr2[0] = 7; // 仅能访问arr2

    std::cout << arr2[0] << '\n';

    return 0;
}
```  

此例中`arr2`由函数`generate()`返回的**临时对象（temporary object）**初始化。与之前不同，该临时对象是**右值（rvalue）**，将在初始化表达式结束时销毁。由于临时对象（及其数据）即将被销毁，我们需要将数据从临时对象转移到`arr2`。  

通常做法是进行潜在的高成本复制（如前例），使`arr2`获得独立数据副本。但此场景的特殊性在于：临时对象即将销毁，不再需要其数据。若进行复制后再销毁原始数据，效率欠佳。  

移动语义（move semantics）简介  
----------------  

若能让`arr2`"窃取"临时对象的数据而非复制，则可避免数据复制。当数据所有权从一个对象转移到另一个对象时，称为数据被**移动（moved）**。移动操作成本通常微不足道（通常仅需两三个指针赋值，远快于复制整个数组！）。  

额外优势：临时对象销毁时因无数据可销毁，进一步节省开销。  

这就是**移动语义（move semantics）**的本质——决定如何将数据从一个对象移动到另一对象的规则。当移动语义被调用时，可移动的数据成员会被移动，不可移动的则被复制。用移动替代复制能使移动语义比复制语义更高效（尤其当昂贵复制被廉价移动替代时）。  

> **关键洞察**  
> 移动语义是一种优化机制：在特定条件下，能以低成本将数据成员的所有权从一个对象转移到另一对象（而非进行昂贵复制）。  
>  
> 无法移动的数据成员仍会被复制。  

移动语义的调用条件  
----------------  

通常，当用同类型对象初始化（或赋值）时，会使用复制语义（假设未发生复制省略）。  

> **相关内容**  
> 复制省略详见课程[14.15 — 类初始化与复制省略](Chapter-14/lesson14.15-class-initialization-and-copy-elision.md)。  

但若满足以下全部条件，则将调用移动语义：  
* 对象类型支持移动语义  
* 对象由同类型的右值（临时）对象初始化（或赋值）  
* 移动未被省略  

遗憾的是：支持移动语义的类型不多。但`std::vector`和`std::string`均支持！  

我们将在[第22章](https://www.learncpp.com#Chapter22)深入探讨移动语义的机制。目前只需了解移动语义的概念及哪些类型支持移动即可。  

可返回支持移动语义的类型（如std::vector）  
----------------  

由于按值返回产生右值，若返回类型支持移动语义，返回值可被移动（而非复制）到目标对象。这使得按值返回对此类类型极为高效！  

> **关键洞察**  
> 可返回支持移动语义的类型（如`std::vector`和`std::string`）。此类类型会移动其值（而非进行昂贵复制）。  
>  
> 此类类型仍应通过常量引用传递。  

等等！高复制成本类型不应按值传递，但若支持移动语义却可按值返回？  
正确。  

以下讨论为可选内容，但有助于理解原因：  

C++中最常见的操作是将值传递给函数并获取返回值。当传递类类型值时，该过程包含4步：  
1. 构造待传递的值  
2. 实际传递值到函数  
3. 构造待返回值  
4. 实际将返回值传回调用方  

以下示例展示使用`std::vector`的流程：  

```cpp
#include <iostream>
#include <vector>

std::vector<int> doSomething(std::vector<int> v2)
{
    std::vector v3 { v2[0] + v2[0] }; // 3 — 构造待返回给调用方的值
    return v3;                         // 4 — 实际返回值
}

int main()
{
    std::vector v1 { 5 };                   // 1 — 构造待传递给函数的值
    std::cout << doSomething(v1)[0] << '\n';// 2 — 实际传递值

    std::cout << v1[0] << '\n';

    return 0;
}
```  

首先假设`std::vector`不支持移动。此时程序产生4次复制：  
1. 构造待传递值：将初始化列表复制到`v1`  
2. 实际传值：将实参`v1`复制到形参`v2`  
3. 构造返回值：将初始化列表复制到`v3`  
4. 实际返回值：将`v3`复制回调用方  

现在讨论优化方案：可用工具包括传引用/地址、省略、移动语义和输出参数。  

步骤1和3无法优化：需要构造`std::vector`传递给函数并返回。`std::vector`拥有其数据所有权，必须复制初始化器。  

可优化的是步骤2和4的复制。  

步骤2的复制源于调用方向被调用函数按值传参。其他选项：  
* 传引用/地址？可行。实参在整个函数调用期间必然存在  
* 可省略此复制？否。省略仅适用于冗余复制/移动场景  
* 输出参数？否。此步骤是传值而非返回值  
* 移动语义？否。实参`v1`是左值。若将数据从`v1`移动到`v2`，`v1`将变为空向量，后续打印`v1[0]`会导致未定义行为  

显然，传常量引用是最佳选择：避免复制、规避空指针问题且兼容左右值实参。  

步骤4的复制源于被调用函数按值向调用方返回值。其他选项：  
* 返回引用/地址？不可行。返回对象是函数内局部变量，返回后即销毁  
* 可省略此复制？是（可能）。编译器可重写代码（根据as-if规则），在调用方作用域构造`v3`以避免复制（但非必然）  
* 输出参数？可行。在调用方作用域构造空`std::vector`对象，通过非常量引用传入函数填充。但存在显著缺点：调用语法冗长、不支持赋值的类型无法使用、难以兼容左右值实参  
* 移动语义？可行。`v3`在函数返回时销毁，可将其数据移动（而非复制）给调用方  

省略是最佳选择，但非开发者可控。对支持移动语义的类型，次优方案是移动语义（当编译器未省略复制时自动启用）。  

总结：对支持移动语义的类型，优先通过**常量引用传递**，通过**按值返回**。  

[下一课 16.6 — 数组与循环](Chapter-16/lesson16.6-arrays-and-loops.md)  
[返回主页](/)  
[上一课 16.4 — 传递std::vector](Chapter-16/lesson16.4-passing-stdvector.md)