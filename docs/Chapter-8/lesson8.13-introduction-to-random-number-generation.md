8.13 — 随机数生成简介  
================================================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2024年8月26日（首次发布于2022年2月18日）  

在某些类型的程序中生成随机数的能力非常有用，尤其是游戏、统计建模程序和需要加密解密的密码学应用。以游戏为例——没有随机事件，怪物会以相同方式攻击，宝藏位置固定不变，地牢布局永不改变…这样的游戏体验将大打折扣。  

现实生活中，我们通过抛硬币、掷骰子或洗牌等行为产生随机性。这些事件并非真正随机，但涉及重力、摩擦力、空气阻力、动量等诸多物理变量，使其几乎无法预测或控制，从而产生实际意义上的随机结果。  

然而计算机并非为利用物理变量而设计——无法抛硬币、掷骰子或洗真实卡牌。现代计算机处于受控的二进制（0或1）电子世界，本质上要求结果尽可能可预测。当计算2+2时，答案必须始终是4，而非偶尔出现3或5。  

因此计算机通常无法生成真正的随机数（至少通过软件）。现代程序多使用算法来模拟随机性。本章将探讨程序生成随机数的理论基础，并介绍后续课程将使用的术语。  

算法与状态  
----------------  

首先了解算法（algorithm）和状态（state）的概念。  

**算法**是解决问题的有限步骤序列。例如处理未排序姓名列表时，可能采用以下步骤：  
* 创建空列表存放排序结果  
* 扫描未排序列表查找首字母序最前的名字  
* 剪切该名字并粘贴至排序列表末尾  
* 重复上述步骤直至未排序列表为空  

这描述了一个自然语言排序算法。算法具有可重用性——若需再次排序，可直接应用相同算法。  

由于计算机执行速度远超人类，算法常通过编程语言实现为可重用函数。以下是生成递增数列的简单算法：  

```cpp
#include <iostream>

int plusOne()
{
    static int s_state { 3 }; // 仅在此函数首次调用时初始化

    // 生成下一个数字
    ++s_state;      // 先修改状态
    return s_state; // 使用新状态生成序列中的下一个数字
}

int main()
{
    std::cout << plusOne() << '\n';
    std::cout << plusOne() << '\n';
    std::cout << plusOne() << '\n';

    return 0;
}
```  

输出：  
```
4
5
6
```  

**有状态（stateful）**算法在多次调用间保留信息，**无状态（stateless）**算法则不存储任何信息。上述`plusOne()`函数具有状态，使用静态变量`s_state`存储最后生成的数字。在算法语境中，**状态（state）**指跨调用保留的状态变量当前值。  

生成序列下个数字的过程分为两步：  
1. 修改当前状态（初始值或前次调用保留）产生新状态  
2. 从新状态生成序列中的下一个数字  

该算法具有**确定性（deterministic）**——给定相同输入（初始值），始终产生相同输出序列。  

伪随机数生成器（PRNGs）  
----------------  

程序通常使用**伪随机数生成器（pseudo-random number generator，PRNG）**来模拟随机性。PRNG是生成具有随机数序列特性的算法。  

以下是生成100个16位伪随机数的简单PRNG示例：  

```cpp
#include <iostream>

// 仅作演示，请勿实际使用
unsigned int LCG16() // 我们的PRNG
{
    static unsigned int s_state{ 0 }; // 仅在此函数首次调用时初始化

    // 生成下一个数字
    s_state = 8253729 * s_state + 2396403; // 先修改状态
    return s_state % 32768; // 使用新状态生成序列中的下一个数字
}

int main()
{
    // 打印100个随机数
    for (int count{ 1 }; count <= 100; ++count)
    {
        std::cout << LCG16() << '\t';

        if (count % 10 == 0)
            std::cout << '\n';
    }
    return 0;
}
```  

输出结果：  
```
4339	838	25337	15372	6783	2642	6021	19992	14859	26462	
...（略）...
```  

每个数字看似随机，但`LCG16()`与前述`plusOne()`结构相似。初始状态设为0，通过数学运算修改状态生成新数字。虽然该PRNG质量不高（奇偶交替明显），但多数PRNG工作原理类似，只是使用更复杂运算提升质量。  

PRNG的种子  
----------------  

PRNG生成的"随机数"序列完全由初始状态决定。给定相同初始值（如0），PRNG每次生成相同序列。要获得不同序列，需改变PRNG的初始状态，这个初始值称为**随机种子（random seed）**或种子。设置种子的过程称为**播种（seeded）**。  

关键点：  
由于PRNG初始状态由种子决定，其所有输出值都基于种子值确定性计算。  

以下程序演示用户输入种子生成随机数：  

```cpp
#include <iostream>

unsigned int g_state{ 0 };

void seedPRNG(unsigned int seed)
{
    g_state = seed;
}

unsigned int LCG16()
{
    g_state = 8253729 * g_state + 2396403;
    return g_state % 32768;
}

void print10()
{
    for (int count{ 1 }; count <= 10; ++count)
    {
        std::cout << LCG16() << '\t';
    }   
    std::cout << '\n';
}

int main()
{
    unsigned int x {};
    std::cout << "Enter a seed value: ";
    std::cin >> x;

    seedPRNG(x); // 播种PRNG
    print10();   // 生成10个随机值

    return 0;
}
```  

三次运行示例：  
```
输入7时生成相同序列
输入9876时生成不同序列
```  

种子质量与欠播种  
----------------  

若希望程序每次运行生成不同随机数，需每次变化种子。但让用户提供种子并不理想，程序需要自动生成随机种子。我们将在下节课讨论种子生成算法。  

PRNG的理论最大唯一序列数由其状态位数决定。例如128位状态的PRNG可生成2^128个唯一序列。但实际输出序列数受种子值数量限制。若种子生成算法只能产生4个种子值，则PRNG最多生成4种序列。  

当PRNG获得的优质种子数据不足时，称为**欠播种（underseeded）**。欠播种可能导致：  
* 连续运行生成的序列高度相关  
* 第N个随机数无法生成特定值  
* 通过初始随机值推测种子  

理想种子应具备：  
* 位数不小于PRNG状态位数  
* 每位独立随机化  
* 0和1均匀分布  
* 无固定位（总为0或1）  
* 与历史种子低相关性  

实践中常需折衷。大型状态PRNG（如梅森旋转算法的19937位）播种困难，常设计为容忍受限种子。开发者若用单个32/64位值播种PRNG（C++标准库设计易导致此问题），将造成严重欠播种。  

良好PRNG的标准（选读）  
----------------  

优质PRNG需具备：  
1. **分布均匀性**：每个数字生成概率近似  
   - 例如骰子PRNG生成36个数应各面出现6次  
   - 不均匀分布将导致程序偏差  

2. **不可预测性**  
   - 即使看似随机的序列（如`LCG16()`输出）也可能被破解  
   - 预测性将导致安全漏洞（如赌博网站被利用）  

3. **良好维度分布**  
   - 应随机覆盖整个可能结果范围  
   - 避免仅生成低/高/奇/偶数  

4. **长周期**  
   - **周期（period）**指序列开始重复前的长度  
   - 所有种子都应具有长周期  
   - 短周期PRNG易陷入循环  

5. **高效性**  
   - 状态内存占用通常小于4096字节  
   - 生成速度影响需要大量随机数的应用  

C++中的随机化  
----------------  

C++通过标准库的`<random>`头文件提供随机功能。截至C++20，提供6种PRNG家族：  

| 类型名称         | 家族               | 周期         | 状态大小 | 性能 | 质量 | 建议使用 |
|------------------|--------------------|--------------|----------|------|------|----------|
| minstd_rand      | 线性同余生成器     | 2^31         | 4字节    | 差   | 极差 | 否       |
| mt19937          | 梅森旋转算法       | 2^19937      | 2500字节 | 良好 | 良好 | 是       |
| ranlux24         | 减法进位法         | 10^171       | 96字节   | 极差 | 良好 | 否       |
| knuth_b          | 混洗线性同余生成器 | 2^31         | 1028字节 | 极差 | 差   | 否       |
| default_random_engine | 实现定义         | 不定         | 不定     | 不定 | 不定 | 否       |
| rand()           | 线性同余生成器     | 2^31         | 4字节    | 差   | 极差 | 否       |  

建议使用梅森旋转算法（Mersenne Twister），其平衡性能与质量。但需注意：  
- 现代标准中梅森旋转稍显过时  
- 生成624个数字后可预测序列，不适用于需要不可预测性的场景（如密码学）  

高质量应用（统计模拟、密码学）建议使用第三方库：  
- 非加密场景：Xoshiro家族、Wyrand  
- 加密场景：Chacha家族  

[下一课 8.14 使用梅森旋转算法生成随机数](Chapter-8/lesson8.14-generating-random-numbers-using-mersenne-twister.md)  
[返回主页](/)  
[上一课 8.12 程序中止](Chapter-8/lesson8.12-halts-exiting-your-program-early.md)