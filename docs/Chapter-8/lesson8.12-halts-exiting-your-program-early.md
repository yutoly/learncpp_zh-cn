8.12 — 终止（提前退出程序）
==========================================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")
2020年12月21日，太平洋标准时间上午11:26
2024年12月28日

本章将介绍的最后一类流程控制语句是终止（halt）。**终止**是一种终止程序执行的流程控制语句。在C++中，终止通过函数（而非关键字）实现，因此终止语句实际上是函数调用。

让我们简要回顾程序正常退出时的情况。当`main()`函数返回时（无论是执行到函数末尾还是通过`return语句`），会依次发生以下事件：
1. 由于离开函数，所有局部变量和函数参数被销毁（遵循常规规则）。
2. 调用特殊函数`std::exit()`，并将`main()`的返回值（`状态码（status code）`）作为参数传入。

那么`std::exit()`是什么？
### std::exit()函数
`std::exit()`函数使程序正常终止。**正常终止（normal termination）**指程序按预期方式退出。注意"正常终止"不表示程序执行成功（这由`状态码（status code）`决定）。例如：假设您编写的程序需要用户输入待处理的文件名，若用户输入无效文件名，程序可能返回非零`状态码`表示失败，但仍属于`正常终止`。

`std::exit()`执行多项清理操作：首先销毁具有静态存储期（static storage duration）的对象；其次对使用过的文件进行杂项清理；最后将控制权交还给操作系统，并将参数作为`状态码`传递。

### 显式调用std::exit()
虽然`std::exit()`会在`main()`函数返回后隐式调用，但也可显式调用以提前终止程序。显式调用时需包含`cstdlib`头文件。

> **关键洞察**  
> 当`main()`返回时，`std::exit`会被隐式调用。

显式调用`std::exit()`的示例：
```
#include <cstdlib> // 引入std::exit()
#include <iostream>

void cleanup()
{
    // 此处代码用于执行各类清理
    std::cout << "清理完成!\n";
}

int main()
{
    std::cout << 1 << '\n';
    cleanup();

    std::exit(0); // 终止程序并向操作系统返回状态码0

    // 以下语句永不执行
    std::cout << 2 << '\n';

    return 0;
}
```
程序输出：
```
1
清理完成!
```
注意：调用`std::exit()`后的语句不会执行，因为程序已终止。虽然此例在`main()`中调用`std::exit()`，但实际可在任意函数中调用以终止程序。

### std::exit()不清理局部变量
显式调用`std::exit()`的重要注意事项：**该函数不会清理任何局部变量**（包括当前函数及调用栈（call stack）中的变量）。若程序依赖局部变量的自我清理机制，调用`std::exit()`可能引发风险。

> **警告**  
> `std::exit()`函数不清理当前函数或调用栈中的局部变量。

### std::atexit
由于`std::exit()`会立即终止程序，您可能需要手动执行清理操作（如关闭数据库/网络连接、释放已分配内存、写入日志等）。

> **扩展阅读**  
> 现代操作系统通常会在应用退出时清理未释放的内存。但主动清理仍有必要：  
> 1. 释放内存是避免程序运行时内存泄漏（memory leaks）的良好习惯，不一致的清理可能导致错误。未妥善清理内存还会影响内存分析工具（memory profilers）的判断。  
> 2. 某些清理对程序行为至关重要：如写入文件后意外退出可能导致缓存数据丢失，提前关闭文件可确保数据写入；或需在关闭前向服务器发送用户会话信息。

上例中我们调用`cleanup()`函数处理清理，但需在每个`exit()`调用前手动添加清理函数会增加负担且易出错。为此，C++提供`std::atexit()`函数，允许注册在通过`std::exit()`终止时自动调用的函数。

> **相关内容**  
> 函数参数传递详见课程[20.1 — 函数指针（Function Pointers）](Chapter-20/lesson20.1-function-pointers.md)。

示例：
```
#include <cstdlib> // 引入std::exit()
#include <iostream>

void cleanup()
{
    // 此处代码用于执行各类清理
    std::cout << "清理完成!\n";
}

int main()
{
    // 注册cleanup()，使其在std::exit()调用时自动执行
    std::atexit(cleanup); // 注意：使用cleanup而非cleanup()，表示此时不立即调用函数

    std::cout << 1 << '\n';

    std::exit(0); // 终止程序并向操作系统返回状态码0

    // 以下语句永不执行
    std::cout << 2 << '\n';

    return 0;
}
```
输出与前例相同：
```
1
清理完成!
```
注意：传递`cleanup()`函数作参数时使用`cleanup`（函数名），而非`cleanup()`（后者会立即调用函数）。`std::atexit()`的优势在于只需注册一次（通常在`main()`中），后续调用`std::exit()`时无需手动清理。

关于`std::atexit()`和清理函数的说明：
1. `main()`终止时隐式调用`std::exit()`也会触发已注册的函数。
2. 注册的函数必须无参数且无返回值。
3. 可注册多个清理函数，它们将按注册顺序的逆序执行（最后注册的函数最先调用）。

> **高级内容**  
> 多线程程序中调用`std::exit()`可能导致崩溃（因调用线程会清理其他线程可能仍在访问的静态对象）。为此C++引入`std::quick_exit()`和`std::at_quick_exit()`：  
> * `std::quick_exit()`正常终止程序但不清理静态对象，可能省略其他清理。  
> * `std::at_quick_exit()`的功能与`std::atexit()`类似，服务于通过`std::quick_exit()`终止的程序。

### std::abort与std::terminate
C++还包含两个终止相关函数：
* **`std::abort()`** 导致程序**异常终止（abnormal termination）**，即程序因运行时错误（如除零操作）无法继续运行。该函数不执行任何清理。
```
#include <cstdlib> // 引入std::abort()
#include <iostream>

int main()
{
    std::cout << 1 << '\n';
    std::abort();

    // 以下语句永不执行
    std::cout << 2 << '\n';

    return 0;
}
```
后续课程[9.6 — 断言（assert）与静态断言（static_assert）](Chapter-9/lesson9.6-assert-and-static_assert.md)将展示`std::abort`的隐式调用场景。
* **`std::terminate()`** 通常与**异常（exceptions）**（后续章节详述）配合使用。虽然可显式调用，但更常见于异常未被处理时（及其他异常相关场景）的隐式调用。默认情况下，`std::terminate()`会调用`std::abort()`。

### 何时应使用终止？
简答是"几乎永不"。局部对象的销毁是C++的重要机制（尤其涉及类时），而上述函数均不清理局部变量。异常机制是处理错误更安全的方式。

> **最佳实践**  
> 仅当无法安全返回main函数时使用终止。若未禁用异常，优先使用异常安全处理错误。

> **提示**  
> 尽管应尽量减少显式终止，但程序仍可能意外关闭：  
> * 程序因崩溃被操作系统终止  
> * 用户强制结束应用  
> * 设备断电  
> * 超新星爆发吞噬地球  
> 良好设计的程序应能处理任意时刻的终止。现代游戏常采用自动存档机制，确保意外关闭后用户可延续进度。

[下一课 8.13 随机数生成简介](Chapter-8/lesson8.13-introduction-to-random-number-generation.md)  
[返回主页](/)  
[上一课 8.11 break与continue](Chapter-8/lesson8.11-break-and-continue.md)