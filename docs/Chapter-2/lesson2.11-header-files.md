2.11 — 头文件（Header Files）
====================

[*作者：Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2025年2月27日（首次发布于2007年6月3日）  

在课程[2.8 — 多文件程序](Chapter-2/lesson2.8-programs-with-multiple-code-files.md)中，我们讨论了如何将程序拆分为多个文件。我们还讲解了如何使用前向声明（forward declarations）实现跨文件访问。当程序仅包含少量小型文件时，手动在每个文件顶部添加前向声明尚可接受。但随着程序规模扩大（使用更多文件和函数），手动维护大量（可能不同的）前向声明将变得极为繁琐。例如，一个包含5个文件的程序，每个文件需要10个前向声明，就需要复制粘贴50次声明。若扩展到100个文件各含100个声明，这种方式显然无法持续！

头文件的概念  
----------------  
C++程序通常使用.cpp扩展名的代码文件，但另一种重要文件类型是**头文件（header file）**。头文件通常以.h为扩展名，偶尔可见.hpp或无扩展名形式。  

关键洞察  
头文件允许我们将声明集中存放，并在需要时导入。这对多文件程序能显著减少代码重复。  

标准库头文件的使用  
----------------  
考虑以下程序：  
```
#include <iostream>

int main()
{
    std::cout << "Hello, world!";
    return 0;
}
```  
该程序通过*std::cout*向控制台输出"Hello, world!"。但程序本身并未提供*std::cout*的定义或声明，编译器如何识别它？答案在于"iostream"头文件已包含*std::cout*的前向声明。当使用`#include <iostream>`时，预处理器会将"iostream"文件内容（包括*std::cout*的声明）复制到当前文件。  

关键洞察  
使用`#include`指令时，被包含文件的内容会插入到包含位置。这是获取外部文件声明的有效方式。  

若没有*iostream*头文件，每次使用*std::cout*时都需手动复制相关声明到每个文件顶部，这需要精确了解*std::cout*的声明方式且工作量巨大。更糟糕的是，若函数原型变更，必须手动更新所有前向声明。因此，直接`#include <iostream>`更为高效。  

通过头文件管理前向声明  
----------------  
回顾课程中的示例，我们有两个文件*add.cpp*和*main.cpp*：  
add.cpp：  
```
int add(int x, int y)
{
    return x + y;
}
```  
main.cpp：  
```
#include <iostream>

int add(int x, int y); // 函数原型形式的前向声明

int main()
{
    std::cout << "3与4的和是" << add(3, 4) << '\n';
    return 0;
}
```  
（若从头创建此示例，请确保将*add.cpp*添加至项目以参与编译）  

在此例中，我们使用前向声明让编译器在编译*main.cpp*时识别*add*标识符。但为每个跨文件函数手动添加前向声明很快会变得繁琐。  

创建头文件可有效解决此问题。头文件包含两部分：  
1. **头文件守卫（header guard）**（下节课[2.12 — 头文件守卫](Chapter-2/lesson2.12-header-guards.md)详解）  
2. 需对外暴露的标识符前向声明  

最佳实践  
头文件命名建议使用.h后缀（除非项目有特殊约定），这是C++长期以来的惯例，多数IDE仍默认使用.h。  

头文件通常与对应的代码文件配对，提供该代码文件中的函数声明。本例中，我们创建*add.h*头文件：  
add.h：  
```
// 此处应添加头文件守卫，为简化暂略（下节课讲解）

// 头文件内容：声明部分
int add(int x, int y); // add.h的函数原型——勿忘分号！
```  
在main.cpp中使用此头文件时需用双引号形式包含：  
main.cpp：  
```
#include "add.h" // 将add.h内容插入此处（注意使用双引号）
#include <iostream>

int main()
{
    std::cout << "3与4的和是" << add(3, 4) << '\n';
    return 0;
}
```  
add.cpp：  
```
#include "add.h" // 将add.h内容插入此处（注意使用双引号）

int add(int x, int y)
{
    return x + y;
}
```  
预处理器处理`#include "add.h"`时，会将*add.h*内容复制到当前位置。由于头文件包含*add()*的前向声明，该声明会被复制到*main.cpp*，实现与手动添加声明相同的效果，程序能正确编译链接。  

![](https://www.learncpp.com/images/CppTutorial/Section1/IncludeHeader.png)  
注意：图中"Standard Runtime Library"应标注为"C++标准库"。  

头文件包含定义导致的单一定义规则（ODR）违规  
----------------  
当前阶段应避免在头文件中放置函数或变量定义。若头文件被多个源文件包含，将导致违反**单一定义规则（ODR）**。  

相关知识点  
单一定义规则详见课程[2.7 — 前向声明与定义](Chapter-2/lesson2.7-forward-declarations.md)。  

示例说明：  
add.h：  
```
// 此处应添加头文件守卫，为简化暂略

// 错误示范：在头文件中定义函数
int add(int x, int y)
{
    return x + y;
}
```  
main.cpp：  
```
#include "add.h" // 复制add.h内容
#include <iostream>

int main()
{
    std::cout << "3与4的和是" << add(3, 4) << '\n';
    return 0;
}
```  
add.cpp：  
```
#include "add.h" // 复制add.h内容
```  
预处理后，main.cpp和add.cpp都包含*add()*定义，链接时会出现两个相同定义，违反ODR第二部分："程序中每个普通函数只能有一个定义"。  

最佳实践  
目前阶段请勿在头文件中定义函数或变量，否则可能因多次包含导致ODR违规。  

作者注  
后续课程将介绍可在头文件中安全定义的特殊类型（不受ODR限制），包括内联函数（inline functions）、内联变量（inline variables）、类型（types）和模板（templates）。  

源文件应包含配对头文件  
----------------  
C++最佳实践要求源文件包含其配对的头文件（若存在）。这有助于编译器在编译期而非链接期发现错误。示例：  
add.h：  
```
// 此处应添加头文件守卫，为简化暂略

int add(int x, int y);
```  
main.cpp：  
```
#include "add.h"
#include <iostream>

int main()
{
    std::cout << "3与4的和是" << add(3, 4) << '\n';
    return 0;
}
```  
add.cpp：  
```
#include "add.h" // 从add.h复制前向声明

double add(int x, int y) // 错误：返回类型应为int
{
    return x + y;
}
```  
编译*add.cpp*时，前向声明`int add(...)`会被复制到文件顶部。当编译器遇到`double add(...)`定义时，能立即发现返回类型不匹配的错误。若未包含头文件，该错误只能在链接时暴露。  

最佳实践  
源文件应包含其配对的头文件。  

避免包含.cpp文件  
----------------  
尽管预处理器支持，但不应`#include` .cpp文件，这些文件应加入项目参与编译。理由包括：  
* 可能导致源文件命名冲突  
* 大型项目中难以避免ODR问题  
* 修改被包含的.cpp文件会导致所有包含它的文件重新编译  
* 不符合惯例  

最佳实践  
避免包含.cpp文件。  

提示  
若项目必须包含.cpp文件才能编译，说明这些文件未参与编译。请将其加入项目或编译命令。  

排错指南  
----------------  
若报错"add.h未找到"：  
* 确认文件名确为add.h（而非add或add.h.txt等）  
* 确保文件与代码文件同目录  

若链接报错"add函数未定义"：  
* 确认add.cpp已加入项目  

尖括号与双引号的区别  
----------------  
使用尖括号`< >`时，预处理器仅在**包含目录（include directories）**中查找头文件（编译器/OS设置的目录）。双引号`" "`则优先在当前目录查找，未找到再搜索包含目录。  

规则  
* 使用双引号包含自定义头文件或当前目录的头文件  
* 使用尖括号包含编译器/系统/第三方库头文件  

为何iostream没有.h扩展名？  
----------------  
历史原因：早期C++标准库头文件带.h后缀（如iostream.h），声明在全局命名空间。标准化时将名称移至std命名空间，并引入无后缀新版头文件。现有四种头文件类型：  

| 类型                | 示例            | 命名空间       |  
|---------------------|-----------------|---------------|  
| C++新版             | \<iostream>     | std           |  
| C兼容新版           | \<cstddef>      | std（必须）   |  
| C++旧版             | \<iostream.h>   | 全局          |  
| C兼容旧版           | \<stddef.h>     | 全局（必须）  |  

最佳实践  
使用无.h的标准库头文件，自定义头文件仍使用.h扩展。  

包含其他目录的头文件  
----------------  
错误方法：在#include中使用相对路径（如`#include "headers/myHeader.h"`）。这会绑定代码与目录结构。  

正确方法：通过编译器/IDE设置**包含路径（include path）**。各平台设置方式：  
* Visual Studio：项目属性 → VC++目录 → 包含目录  
* Code::Blocks：项目 → 构建选项 → 搜索目录  
* g++：使用`-I`选项指定目录（如`g++ -o main -I./includes main.cpp`）  
* VS Code：在tasks.json的"Args"添加`"-I./includes"`  

头文件的传递性包含  
----------------  
当头文件A需要头文件B的声明时，A应包含B。当源文件包含A时，会隐式获得B的内容（称为**传递性包含（transitive includes）**）。但不应依赖传递性包含，因为：  
* 头文件实现可能变化  
* 不同系统可能表现不同  

最佳实践  
每个文件应显式包含所需的所有头文件。  

包含顺序建议  
----------------  
为最大限度暴露缺失包含的问题，建议按以下顺序排列#include：  
1. 配对头文件（如add.cpp包含add.h）  
2. 同项目其他头文件  
3. 第三方库头文件  
4. 标准库头文件  

每组头文件按字母序排列（第三方库有特殊要求除外）。  

头文件最佳实践  
----------------  
* 始终使用头文件守卫  
* 暂时不在头文件定义变量/函数  
* 头文件与源文件同名（如grades.h对应grades.cpp）  
* 每个头文件职责单一，尽量独立  
* 显式包含所需头文件，避免依赖传递性包含  
* 头文件应包含其依赖的其他头文件  
* 仅包含必要内容  
* 避免包含.cpp文件  
* 使用说明文档放在头文件，实现细节文档放在源文件  

[下一课 2.12 头文件守卫](Chapter-2/lesson2.12-header-guards.md)  
[返回主页](/)  
[上一课 2.10 预处理器简介](Chapter-2/lesson2.10-introduction-to-the-preprocessor.md)