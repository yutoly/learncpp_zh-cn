21.1 — 操作符重载（operator overloading）简介
============================================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2007年9月24日下午2:23（首次发布）  
2023年9月11日更新  

在课程[11.1 — 函数重载（function overloading）简介](Chapter-11/lesson11.1-introduction-to-function-overloading.md)中，我们学习了函数重载机制。该机制允许创建多个同名函数，只要每个函数具有唯一的函数原型（function prototype）。这使您能为不同数据类型创建函数变体，而无需为每个变体构思唯一名称。

在C++中，操作符（operator）是通过函数实现的。通过对操作符函数进行函数重载，您可以定义适用于不同数据类型（包括自定义类）的自定义操作符版本。这种通过函数重载来重新定义操作符的行为称为**操作符重载（operator overloading）**。

本章我们将探讨与操作符重载相关的主题。  

**作为函数的操作符**  
考虑以下示例：  
```
int x { 2 };
int y { 3 };
std::cout << x + y << '\n';
```  
编译器为整型操作数提供了内置（built-in）的加法操作符（+）版本——该函数将整型x和y相加并返回整型结果。当看到表达式`x + y`时，可在脑海中将其转换为函数调用`operator+(x, y)`（其中operator+是函数名）。  

再看类似代码片段：  
```
double z { 2.0 };
double w { 3.0 };
std::cout << w + z << '\n';
```  
编译器也为双精度浮点型操作数提供了内置加法操作符版本。表达式w + z转换为函数调用`operator+(w, z)`，通过函数重载机制，编译器将调用该操作符的双精度版本而非整型版本。  

现在考虑尝试对程序定义类的两个对象进行加法操作：  
```
Mystring string1 { "Hello, " };
Mystring string2 { "World!" };
std::cout << string1 + string2 << '\n';
```  
这种情况下您期望发生什么？直观预期是控制台输出"Hello, World!"字符串。但由于Mystring是程序定义类型，编译器没有适用于该类型的加法操作符内置版本，因此会产生错误。要实现预期效果，我们需要编写重载函数来告知编译器如何处理两个Mystring类型操作数的+操作符。下一课将详细讲解具体实现方法。  

**解析重载操作符**  
当编译器遇到包含操作符的表达式时，使用以下规则进行解析：  
* 若*所有*操作数均为基本数据类型（fundamental data type），且存在对应内置例程（routine）则调用之，否则产生编译错误  
* 若*任一*操作数为程序定义类型（如自定义类或枚举类型），编译器将使用函数重载解析算法（参见课程[11.3 — 函数重载解析与二义性匹配](Chapter-11/lesson11.3-function-overload-resolution-and-ambiguous-matches.md)）寻找最佳匹配的重载操作符。该过程可能涉及：  
  - 隐式转换操作数以匹配重载操作符的参数类型  
  - 通过重载类型转换（overloaded typecast）将程序定义类型隐式转换为基本类型以匹配内置操作符  
  - 若找不到匹配项或存在二义性匹配，则报错  

**操作符重载的限制**  
第一，C++中几乎所有现有操作符都可重载。例外包括：条件运算符（?:）、sizeof、作用域运算符（::）、成员选择符（.）、指针成员选择符（.*）、typeid以及类型转换运算符。  

第二，只能重载现有操作符，不可创建新操作符或重命名现有操作符。例如无法创建`operator**`来实现幂运算。  

第三，重载操作符的至少一个操作数必须是用户定义类型（user-defined type）。这意味着可以重载`operator+(int, Mystring)`，但不能重载`operator+(int, double)`。  

由于标准库类被视为用户定义类型，因此可以定义`operator+(double, std::string)`。但这是不良实践，因为未来语言标准可能定义此重载，导致使用自定义重载的程序崩溃。因此最佳实践是：重载操作符应作用于至少一个程序定义类型（作为函数参数或隐式对象）。  

最佳实践  
重载操作符应作用于至少一个程序定义类型（作为函数参数或隐式对象）。  

第四，无法改变操作符支持的操作数数量。  
最后，所有操作符保持默认优先级（precedence）和结合性（associativity），这些属性无法更改。  

某些新手尝试重载按位异或运算符（^）实现幂运算。但在C++中，operator^的优先级低于基本算术运算符，会导致表达式求值错误。在基础数学中，幂运算优先于基本算术，因此4 + 3^2解析为4 + (3^2) => 4 + 9 => 13。而在C++中，算术运算符优先级高于operator^，4 + 3^2解析为(4 + 3)^2 => 7^2 => 49。要实现正确运算，每次都需要显式添加括号（如4 + (3^2)），这既不直观又容易出错。  

由于优先级问题，通常建议以接近操作符原始意图的方式使用重载操作符。  

最佳实践  
重载操作符时，应尽量保持其功能与原始设计意图一致。  

此外，由于操作符缺乏描述性名称，其用途可能不够明确。例如，operator+对字符串类进行连接是合理选择，但operator-的预期功能则不明确。  

最佳实践  
若重载操作符的功能不够清晰直观，应改用具名函数。  

最后，重载操作符的返回值应与原始操作符保持一致。不修改操作数的运算符（如算术运算符）通常应返回值（by value），修改左操作数的运算符（如前置递增、赋值运算符）通常应返回左操作数的引用（by reference）。  

最佳实践  
不修改操作数的运算符（如算术运算符）通常应返回值。  
修改左操作数的运算符（如前置递增、赋值运算符）通常应返回左操作数的引用。  

在这些限制范围内，您仍可为自定义类找到大量有用的重载功能！例如：  
* 重载+运算符连接自定义字符串类对象  
* 重载<<运算符实现类对象便捷输出（至屏幕或文件）  
* 重载==运算符比较两个类对象  

这些特性使操作符重载成为C++最强大的功能之一——它让您能够以更直观的方式操作自定义类。  

后续课程将深入探讨不同类型操作符的重载方法。  

[下一课 21.2 使用友元函数重载算术运算符](Chapter-21/lesson21.2-overloading-the-arithmetic-operators-using-friend-functions.md)  
[返回主页](/)  
[上一课 20.x 第20章总结与测验](Chapter-20/lesson20.x-chapter-20-summary-and-quiz.md)