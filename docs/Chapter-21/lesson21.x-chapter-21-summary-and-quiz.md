21.x — 第21章总结与测验  
===================================  

[*作者：Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  

2016年8月9日 下午2:44（太平洋夏令时）  
2024年12月28日  

本章我们探讨了运算符重载、类型转换重载以及与拷贝构造函数相关的主题。  

### 总结  

**运算符重载**是函数重载的变体，允许为自定义类重载运算符。重载运算符时应尽量保持其原始语义。若运算符应用于自定义类时含义不明确，应改用命名函数。  

运算符可重载为普通函数、友元函数或成员函数。以下经验法则可帮助选择最佳形式：  
* 重载赋值（=）、下标（[]）、函数调用（()）或成员选择（->）运算符时，应作为成员函数  
* 重载一元运算符时，应作为成员函数  
* 重载修改左操作数的二元运算符（如 operator+=）时，优先作为成员函数  
* 重载不修改左操作数的二元运算符（如 operator+）时，应作为普通函数或友元函数  

**类型转换**可重载为转换函数，用于显式或隐式地将类转换为其他类型。  

**拷贝构造函数**是用于从同类型对象初始化新对象的特殊构造函数。在以下场景使用：直接/统一初始化、拷贝初始化（Fraction f = Fraction(5,3)）、传值或返回值时。  

若未提供拷贝构造函数，编译器会自动生成执行**成员逐一初始化**（memberwise initialization）的版本。出于优化目的，编译器可能省略拷贝构造函数的调用（即使有副作用），因此不要依赖其执行。  

构造函数默认被视为**转换构造函数**，编译器会使用它们进行隐式类型转换。使用 explicit 关键字可阻止隐式转换。可通过 delete 关键字删除类中的函数（包括拷贝构造函数和重载赋值运算符），被删除函数被调用时将引发编译错误。  

**赋值运算符**可重载以实现类对象赋值。未提供时编译器自动生成执行**成员逐一赋值**的版本。重载赋值运算符应始终包含自赋值检查（除非自然处理或使用拷贝交换惯用法）。  

拷贝构造函数与赋值运算符的使用场景区别：  
* 需要创建新对象时使用拷贝构造函数（含传值/返回值）  
* 不需创建新对象时使用赋值运算符  

编译器提供的拷贝构造函数和赋值运算符默认执行**浅拷贝**。若类涉及动态内存管理，需显式定义这些函数以执行**深拷贝**。更推荐使用标准库类来避免手动内存管理。  

### 测验时间  

**问题1**  
假设 Point 是类，point 是该类实例，以下运算符应使用普通/友元函数还是成员函数重载？  

a) `point + point`  
  
<details><summary>答案</summary>二元 operator+ 应作为普通/友元函数实现</details>  

b) `-point`  
  
<details><summary>答案</summary>一元 operator- 应作为成员函数实现</details>  

c) `std::cout << point`  
  
<details><summary>答案</summary>operator<< 必须作为普通/友元函数实现</details>  

d) `point = 5;`  
  
<details><summary>答案</summary>operator= 必须作为成员函数实现</details>  

**问题2**  
编写跟踪整数平均值的 Average 类：  
a) 实现要求的程序  
  
<details><summary>代码实现</summary>  
（代码内容详见原文解决方案）  
</details>  

b) 是否需要自定义拷贝构造函数或赋值运算符？  
  
<details><summary>答案</summary>不需要，成员逐一初始化/拷贝即可满足需求</details>  

c) 为何使用 std::int32_t？  
  
<details><summary>答案</summary>确保32位整型，避免16位平台的数值限制</details>  

**问题3**  
实现自定义整型数组类 IntArray：  
  
<details><summary>代码实现</summary>  
（代码内容详见原文解决方案，包含深拷贝实现）  
</details>  

**问题4**  
实现定点数类 FixedPoint2：  
各步骤解决方案详见原文代码实现，包含：  
- 小数溢出处理  
- 双精度构造函数  
- 运算符重载（==、>>、-、+）  

[下一课 21.y — 第21章项目](Chapter-21/lesson21.y-chapter-21-project.md)  
[返回主页](/)  
[上一课 21.14 — 运算符重载与函数模板](Chapter-21/lesson21.14-overloading-operators-and-function-templates.md)