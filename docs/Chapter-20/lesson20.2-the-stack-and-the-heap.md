20.2 — 栈与堆  
==============================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2007年8月10日 下午4:56（太平洋夏令时）  
2024年6月25日更新  

程序使用的内存通常划分为若干不同区域，称为**段（segment）**：  
* **代码段（code segment）**（亦称文本段（text segment））：存储编译后的程序。该段通常为只读。  
* **bss段（bss segment）**（亦称未初始化数据段（uninitialized data segment））：存储零初始化的全局变量（global variable）和静态变量（static variable）。  
* **数据段（data segment）**（亦称初始化数据段（initialized data segment））：存储已初始化的全局变量和静态变量。  
* **堆（heap）**：动态分配变量（dynamically allocated variable）的内存来源。  
* **调用栈（call stack）**：存储函数参数（function parameter）、局部变量（local variable）及其他函数相关信息。  

本章重点讨论堆与栈，因其承载了最核心的运作机制。  

**堆段**  
----------------  
**堆段（heap segment）**（亦称**自由存储区（free store）**）负责追踪动态内存分配（dynamic memory allocation）。我们在课程[19.1 — new与delete动态内存分配](Chapter-19/lesson19.1-dynamic-memory-allocation-with-new-and-delete.md)中已初步讨论过堆，此处进行回顾：  

在C++中，使用`new`运算符分配内存时，该内存位于应用程序的堆段。假设`int`占4字节：  
```cpp
int* ptr { new int }; // new int在堆中分配4字节
int* array { new int[10] }; // new int[10]在堆中分配40字节
```  
`operator new`返回此内存地址，可将其存入指针（pointer）。用户无需关注空闲内存定位与分配的底层机制。但需注意：连续的内存请求可能不会分配到连续地址！  
```cpp
int* ptr1 { new int };
int* ptr2 { new int };
// ptr1与ptr2的地址可能不连续
```  
删除动态分配的变量时，内存将“返还”堆，后续分配请求可重新分配该内存。请谨记：删除指针不会删除变量，仅将关联地址的内存归还操作系统。  

堆的优缺点：  
* 堆内存分配速度相对较慢  
* 已分配内存会持续占用，直至显式释放（警惕内存泄漏（memory leak））或程序终止（此时操作系统应清理）  
* 必须通过指针访问动态分配的内存。解引用指针（dereferencing pointer）比直接访问变量慢  
* 堆是大容量内存池，可分配大型数组（array）、结构体（structure）或类（class）  

**调用栈**  
----------------  
**调用栈（call stack）**（通常简称**栈（stack）**）的作用更为关键。它追踪从程序启动到当前执行点所有活跃函数（active function）（已调用但未终止的函数），并管理所有函数参数和局部变量的分配。  

调用栈以**栈数据结构（stack data structure）**实现。理解调用栈前需先掌握栈数据结构。  

**栈数据结构**  
----------------  
**数据结构（data structure）**是高效组织数据的编程机制。您已接触过数组（array）和结构体（struct）等数据结构，它们提供了高效存储与访问数据的方式。编程中还有许多常用数据结构（标准库实现了其中多种），栈即其中之一。  

以餐厅餐盘栈为例：因餐盘较重且堆叠，只能执行三种操作：  
1. 查看顶部餐盘表面  
2. 移走顶部餐盘（若存在下层餐盘则暴露之）  
3. 将新餐盘置于栈顶（若存在下层餐盘则隐藏之）  

计算机编程中，栈是容纳多个变量的容器数据结构（类似数组）。但数组允许**随机访问（random access）**（任意顺序访问/修改元素），而栈的限制更多。栈的操作对应上述行为：  
1. 查看栈顶项（通常通过`top()`函数，有时称`peek()`）  
2. 移除栈顶项（通过`pop()`函数）  
3. 将新项压入栈顶（通过`push()`函数）  

栈是**后进先出（last-in, first-out, LIFO）**结构。最后压入的项最先弹出。若将新餐盘置于栈顶，则移除的第一个餐盘正是最后压入者。随着压栈操作，栈增大；弹栈操作则使栈缩小。例如：  
```
栈：空
压入1
栈：1
压入2
栈：1 2
压入3
栈：1 2 3
弹出
栈：1 2
弹出
栈：1
```  

邮箱类比能更准确阐释调用栈：想象一组垂直堆叠的邮箱，每个邮箱仅容纳一项且初始为空。邮箱固定不可增减数量。如何模拟栈行为？  

首先用标记（如便签）追踪最底部空邮箱位置（初始位于栈底）。压栈时：将项放入标记邮箱（首个空邮箱），并将标记上移一个邮箱。弹栈时：将标记下移一个邮箱（指向顶部非空邮箱）并移出该项。标记下方所有内容视为“在栈上”，标记及上方内容则不在栈中。  

**调用栈段**  
----------------  
调用栈段（call stack segment）存储调用栈内存。程序启动时，操作系统将`main()`函数压入调用栈，随后开始执行。  

遇到函数调用时，该函数被压入调用栈。当前函数结束时，该函数从调用栈弹出（此过程亦称**栈回退（unwinding the stack）**）。因此，通过观察调用栈中的函数，可追溯当前执行点的完整调用链。  

邮箱类比与调用栈运作高度吻合：栈本身是固定大小的连续内存地址块，邮箱对应内存地址，压入/弹出的“项”称为**栈帧（stack frame）**。栈帧记录单次函数调用的所有关联数据（后续详述）。“标记”是CPU中的寄存器（register）（小型内存），称为**栈指针（stack pointer, SP）**，用于追踪当前调用栈顶部位置。  

进一步优化：弹栈时仅需下移栈指针——无需清理或清零被弹出栈帧的内存（类比不清空邮箱）。该内存不再视为“在栈上”（栈指针将位于此地址或之下），故不会被访问。若后续向此内存压入新栈帧，将直接覆盖旧值。  

**调用栈实战**  
----------------  
深入分析调用栈工作流程。函数调用时的步骤序列：  
1. 程序遇到函数调用  
2. 构造栈帧并压入栈。栈帧包含：  
   * **返回地址（return address）**：函数调用后指令的地址，供CPU记录函数退出后的返回位置  
   * 所有函数实参（function argument）  
   * 局部变量内存空间  
   * 需在函数返回时恢复的寄存器（register）副本  
3. CPU跳转至函数起始点  
4. 执行函数内指令  

函数终止时：  
1. 从调用栈恢复寄存器  
2. 弹出栈帧。释放所有局部变量和参数的内存  
3. 处理返回值（return value）  
4. CPU从返回地址继续执行  

返回值处理方式因计算机架构而异：某些架构将其作为栈帧部分，另一些使用CPU寄存器。  

通常无需深究调用栈细节，但理解“函数调用时压栈，返回时弹栈（回退）”的核心机制，是掌握**递归（recursion）**及调试关键概念的基础。  

> **技术说明**  
> 某些架构中调用栈向内存地址0反方向增长，另一些则向0方向增长。因此新栈帧地址可能高于或低于前序栈帧。  

**简易调用栈示例**  
----------------  
分析以下程序：  
```cpp
int foo(int x)
{
    // b点
    return x;
} // foo在此处弹出调用栈

int main()
{
    // a点
    foo(5); // foo在此处压入调用栈
    // c点
    return 0;
}
```  
标记点调用栈状态：  
**a点**：  
```
main()
```  
**b点**：  
```
foo()（含参数x）
main()
```  
**c点**：  
```
main()
```  

**栈溢出**  
----------------  
栈容量有限，故仅能存储有限信息。Windows版Visual Studio默认栈大小为1MB，Unix系统的g++/Clang可达8MB。若程序尝试存入过多信息，将导致**栈溢出（stack overflow）**——当栈内存全部分配后，后续分配会侵入其他内存区域。  

栈溢出通常由以下原因引发：  
* 栈上分配过多变量  
* 过深嵌套函数调用（如函数A调用B，B调用C，C调用D等）  

现代操作系统中，栈溢出通常引发访问冲突（access violation）并终止程序。  

以下示例程序可能导致栈溢出（运行将崩溃）：  
```cpp
#include <iostream>

int main()
{
    int stack[10000000]; // 超大数组（约40MB）
    std::cout << "hi" << stack[0]; // 使用stack[0]避免编译器优化掉数组
    return 0;
}
```  
Windows（Visual Studio）运行结果：  
```
HelloWorld.exe (进程 15916) 退出代码 -1073741571。
```  
`-1073741571`的十六进制为`c0000005`，即Windows访问冲突代码。注意“hi”未被打印——程序在此之前终止。  

另一导致栈溢出的程序（原理不同）：  
```cpp
// 鸣谢读者yellowEmu的计数器建议
#include <iostream>

int g_counter{ 0 };

void eatStack()
{
    std::cout << ++g_counter << ' ';

    // 条件判断避免编译器无限递归警告
    if (g_counter > 0)
        eatStack(); // eatStack()递归调用自身

    // 防止编译器进行尾调用优化（tail-call optimization）
    std::cout << "hi";
}

int main()
{
    eatStack();
    return 0;
}
```  
此程序中，每次调用`eatStack()`会压入一个栈帧。因`eatStack()`递归调用自身且永不返回，最终栈耗尽内存导致溢出。  

> **作者注**  
> 在Windows 10（Visual Studio Community IDE）运行时：  
> * 调试模式：`eatStack()`调用4848次后崩溃  
> * 发布模式：调用128,679次后崩溃  

**延伸内容**  
递归函数详见后续课程[20.3 — 递归](Chapter-20/lesson20.3-recursion.md)。  

栈的优缺点：  
* 栈内存分配速度较快  
* 栈上分配的内存只要在栈中即保持作用域（scope），弹出栈时被销毁  
* 栈内存均在编译期（compile time）确定，故可直接通过变量访问  
* 栈空间较小，不宜进行大量消耗栈的操作（如分配/复制大型数组或内存密集型结构）  

> **作者注**  
> [此评论](introduction-to-objects-and-variables/#comment-560618)补充了栈变量布局及运行时内存地址分配的简化说明。  

[下一课 20.3 递归](Chapter-20/lesson20.3-recursion.md)  
[返回主页](/)  
[上一课 20.1 函数指针](Chapter-20/lesson20.1-function-pointers.md)