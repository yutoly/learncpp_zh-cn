19.1 — new与delete动态内存分配  
=====================================================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2025年1月1日（首次发布于2007年7月13日）  

动态内存分配的必要性  
----------------  

C++支持三种基本内存分配方式，其中您已接触过两种：  

* **静态内存分配（static memory allocation）** 用于静态变量和全局变量。这些变量的内存在程序运行时分配一次，并持续整个程序生命周期。  
* **自动内存分配（automatic memory allocation）** 用于函数参数和局部变量。这些变量的内存在进入相关代码块时分配，退出时释放，可多次重复。  
* **动态内存分配（dynamic memory allocation）** 是本节主题。  

前两种分配方式的共同点：  
* 变量/数组大小必须在编译时确定  
* 内存分配和释放自动进行（变量实例化/销毁时）  

多数情况下这已足够，但处理外部输入（用户或文件）时可能遇到限制。例如：  
* 存储用户姓名但无法预知长度  
* 读取未知数量的磁盘记录  
* 游戏中动态变化的怪物数量  

若必须静态声明大小，只能预估最大值：  
```cpp
char name[25];         // 希望用户名字少于25个字符！
Record record[500];    // 假设记录不超过500条！
Monster monster[40];   // 最多40个怪物
Polygon rendering[30000]; // 确保3D模型不超过3万面！
```  

此方案存在四大缺陷：  
1. **内存浪费**：例如25字符数组平均只使用12字符  
2. **状态追踪困难**：需额外机制判断数组元素是否被使用  
3. **栈容量限制**：默认栈空间通常较小（如Visual Studio默认1MB），容易溢出：  
```cpp
int main() {
    int array[1000000]; // 分配400万字节（约4MB）
}
```  
4. **人为限制与数组越界**：当数据超出预定容量时导致错误  

动态内存分配的优势  
----------------  

通过动态内存分配，程序运行时按需向操作系统请求内存。这类内存来自**堆（heap）**而非栈，现代系统堆空间可达GB级别。  

单变量动态分配  
----------------  

使用**new**运算符分配单个变量：  
```cpp
new int; // 动态分配整型内存（结果未保存）
```  
通常将返回地址存入指针变量：  
```cpp
int* ptr{ new int }; // 动态分配整型并将地址存入ptr
```  
通过指针访问内存：  
```cpp
*ptr = 7; // 向分配的内存写入值
```  
访问堆对象比栈对象慢，因为需要两次寻址（先取指针地址，再取值）。  

动态内存工作原理  
----------------  

程序可用内存分为多个区域：代码区、函数调用栈等。动态分配时，操作系统从空闲内存划拨区域，程序负责在使用后归还。  

关键理解  
----------------  

栈对象自动管理内存地址，堆对象需手动管理。通过new返回的指针地址是访问堆对象的唯一途径。  

动态变量初始化  
----------------  
```cpp
int* ptr1{ new int(5) };   // 直接初始化
int* ptr2{ new int{6} };   // 统一初始化
```  

删除单变量  
----------------  

使用**delete**运算符归还内存：  
```cpp
delete ptr;    // 归还ptr指向的内存
ptr = nullptr; // 置为空指针
```  

删除操作实质  
----------------  

delete将内存归还系统，指针变量仍存在但指向无效内存。删除非动态分配指针会导致未定义行为。  

悬空指针（dangling pointer）  
----------------  

指向已释放内存的指针称为悬空指针，解引用或二次删除将导致未定义行为：  
```cpp
int main() {
    int* ptr{ new int };
    *ptr = 7;
    delete ptr; // ptr成为悬空指针

    std::cout << *ptr; // 未定义行为
    delete ptr;        // 二次删除同样危险
}
```  

多个悬空指针示例：  
```cpp
int main() {
    int* ptr{ new int{} };
    int* otherPtr{ ptr }; // 共享地址

    delete ptr;       // 两者都成为悬空指针
    ptr = nullptr;    // 仅ptr置空
    // otherPtr仍悬空
}
```  

最佳实践  
----------------  
1. 避免多指针指向同一动态内存  
2. 删除后立即置空指针（除非指针即将离开作用域）  

new操作可能失败  
----------------  

默认内存不足时抛出bad_alloc异常，可用nothrow版本返回空指针：  
```cpp
int* value{ new(std::nothrow) int{} }; // 失败返回nullptr
if (!value) {
    std::cerr << "内存分配失败\n";
}
```  

空指针与动态内存  
----------------  

空指针（nullptr）表示未分配内存，条件分配示例：  
```cpp
if (!ptr) ptr = new int; // 若ptr为空则分配
```  
删除空指针是安全的：  
```cpp
delete ptr; // 若ptr为空则无操作
```  

内存泄漏（memory leak）  
----------------  

动态内存未被释放且失去地址引用时发生泄漏：  
```cpp
void doSomething() {
    int* ptr{ new int{} };
} // ptr离开作用域，内存永久丢失
```  

其他泄漏场景：  
```cpp
int* ptr{ new int{} };
ptr = new int{}; // 原地址丢失，泄漏第一次分配的内存
```  

预防措施：  
```cpp
int* ptr{ new int{} };
delete ptr;     // 先释放
ptr = new int{}; // 再重新分配
```  

总结  
----------------  

new和delete实现单变量动态内存管理：  
* 动态内存持续到显式释放或程序结束  
* 避免解引用悬空或空指针  

下节课将探讨动态数组分配。  

[下一课 19.2 动态分配数组](Chapter-19/lesson19.2-dynamically-allocating-arrays.md)  
[返回主页](/)  
[上一课 18.4 代码计时](Chapter-18/lesson18.4-timing-your-code.md)