6.8 — 逻辑运算符  
================================================

[*作者：Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2007年6月15日下午1:35（太平洋夏令时）  
2024年11月26日更新  

虽然关系（比较）运算符可用于测试某个条件是否为真，但它们每次只能测试一个条件。我们经常需要同时判断多个条件。例如要确认彩票是否中奖，需要将所选多个号码与中奖号码逐一比对。在6位数的彩票中，这需要执行6次比较且*全部*为真。其他情况下，我们可能需要判断多个条件中是否有任意一个为真。例如当生病、过度疲劳或彩票中奖时决定请假，这就需要检查3个条件中是否有*任意*一个为真。  

逻辑运算符使我们能够测试多个条件。C++提供3种逻辑运算符：  

| 运算符符号 | 使用示例 | 运算逻辑 |  
|------------|----------|----------|  
| 逻辑非 ! | !x | 当x为假时结果为真，x为真时结果为假 |  
| 逻辑与 && | x && y | 当x和y都为真时结果为真，否则为假 |  
| 逻辑或 || | x || y | 当x或y任一（或两者）为真时结果为真，否则为假 |  

**逻辑非**  
在课程[4.9 — 布尔值](Chapter-4/lesson4.9-boolean-values.md)中已介绍过逻辑非一元运算符。其作用可总结如下：  

| 逻辑非（运算符!） | 操作数 | 结果 |  
|--------------------|--------|------|  
| true | false |  
| false | true |  

如果*逻辑非*的操作数求值为true，则结果为false；若操作数为false，则结果为true。即逻辑非将布尔值从true翻转为false，反之亦然。  

逻辑非常用于条件判断：  
```cpp
bool tooLarge { x > 100 }; // x>100时tooLarge为true
if (!tooLarge)
    // 处理x
else
    // 输出错误
```  

需注意逻辑非具有极高的优先级。新手常犯以下错误：  
```cpp
#include <iostream>

int main()
{
    int x{5};
    int y{7};

    if (!x > y)
        std::cout << x << "不大于" << y << '\n';
    else
        std::cout << x << "大于" << y << '\n';

    return 0;
}
```  
该程序输出：  
```
5大于7
```  
但实际上x并不大于y。由于逻辑非的优先级高于大于运算符，表达式`!x > y`实际解析为`(!x) > y`。当x=5时，!x为0，`0 > y`为假，故执行else分支！  

正确写法应为：  
```cpp
if (!(x > y))
```  

> **最佳实践**  
> 若逻辑非要作用于其他运算符的结果，需用括号包裹目标表达式。  
>  
> 简单的逻辑非使用（如`if (!value)`）无需括号。  

**逻辑或**  
逻辑或运算符用于测试两个条件是否至少有一个为真。  

| 逻辑或（运算符||） | 左操作数 | 右操作数 | 结果 |  
|---------------------|----------|----------|------|  
| false | false | false |  
| false | true | true |  
| true | false | true |  
| true | true | true |  

示例程序：  
```cpp
#include <iostream>

int main()
{
    std::cout << "输入数字：";
    int value{};
    std::cin >> value;

    if (value == 0 || value == 1)
        std::cout << "输入了0或1\n";
    else
        std::cout << "未输入0或1\n";
    return 0;
}
```  

> **警告**  
> 切勿写成`if (value == 0 || 1)`，这会因1隐式转为true导致条件恒真。正确方式应为多次比较变量：`value == 0 || value == 1`  

可串联多个逻辑或条件：  
```cpp
if (value == 0 || value == 1 || value == 2 || value == 3)
    std::cout << "输入了0、1、2或3\n";
```  

> **注意**  
> 不要混淆逻辑或`||`与位或`|`（详见课程[O.2 — 位运算符](Chapter-O/lessonO.2-bitwise-operators.md)）。  

**逻辑与**  
逻辑与运算符要求两个操作数都为真时才返回真。  

| 逻辑与（运算符&&） | 左操作数 | 右操作数 | 结果 |  
|---------------------|----------|----------|------|  
| false | false | false |  
| false | true | false |  
| true | false | false |  
| true | true | true |  

示例：判断数值是否在10到20之间  
```cpp
#include <iostream>

int main()
{
    std::cout << "输入数字：";
    int value{};
    std::cin >> value;

    if (value > 10 && value < 20)
        std::cout << "数值在10到20之间\n";
    else
        std::cout << "数值不在该范围\n";
    return 0;
}
```  

可串联多个逻辑与条件：  
```cpp
if (value > 10 && value < 20 && value != 16)
    // 执行操作
```  

**短路求值**  
逻辑与要求两操作数都为真。若左操作数为假，则右操作数不会被求值（直接返回假），这称为**短路求值**。类似地，逻辑或的左操作数为真时，右操作数也不会被求值。  

> **警告**  
> 避免在复合表达式中使用有副作用的运算符。例如：  
> ```cpp
> if (x == 1 && ++y == 2) // 若x≠1，++y不会执行！
> ```  

> **关键洞察**  
> 逻辑或和逻辑与的求值顺序是例外，标准规定左操作数总是先求值。  

**混合使用逻辑与和逻辑或**  
由于逻辑与优先级高于逻辑或，表达式`value1 || value2 && value3`会被解析为`value1 || (value2 && value3)`。建议显式使用括号明确优先级：  
```cpp
(value1 && value2) || (value3 && value4)
```  

> **最佳实践**  
> 混合使用时，用括号明确每个操作的优先级。  

**德摩根定律**  
`!(x && y)`等价于`!x || !y`  
`!(x || y)`等价于`!x && !y`  

可通过真值表验证：  

| x | y | !x | !y | !(x&&y) | !x\|\|!y |  
|---|---|----|----|---------|----------|  
| F | F | T | T | T | T |  
| F | T | T | F | T | T |  
| T | F | F | T | T | T |  
| T | T | F | F | F | F |  

**逻辑异或（XOR）运算符在哪？**  
C++未提供显式逻辑异或运算符（`operator^`是位异或）。但可通过`operator!=`实现布尔操作数的逻辑异或：  
```cpp
if (a != b) // a异或b（a、b为布尔型）
```  
多操作数异或：  
```cpp
if (a != b != c) // 当奇数个操作数为真时成立
```  

> **进阶阅读**  
> 对于非布尔操作数，可用双重否定转换：  
> ```cpp
> if (!!a != !!b != !!c) // 适用于可转为布尔值的类型
> ```  

**运算符替代表示法**  
C++支持用单词替代符号的运算符表示法：  

| 运算符 | 替代关键字 |  
|--------|------------|  
| && | and |  
| \|\| | or |  
| ! | not |  

示例：  
```cpp
std::cout << !a && (b || c);  
std::cout << not a and (b or c); // 等效
```  

> **建议**  
> 推荐使用符号形式，因其在现有代码中更常见。  

测验时间  
----------------  

**问题1**  
评估以下表达式（使用=>表示推导步骤，[]表示短路求值忽略部分）：  
a) (true && true) || false  
=> true || [false] => true  

b) (false && true) || true  
=> false || true => true  

c) (false && true) || false || true  
=> false || false || true => true  

d) (5 > 6 || 4 > 3) && (7 > 8)  
=> (false || true) && false => false  

e) !(7 > 6 || 3 > 4)  
=> !(true || [3>4]) => false  

**问题2**  
使用`operator!`重写判断偶数的函数：  
```cpp
bool isEven(int x)
{
    return !(x % 2);
}
```  

[下一课 6.x — 第6章总结与测验](Chapter-6/lesson6.x-chapter-6-summary-and-quiz.md)  
[返回主页](/)  
[上一课 6.7 — 关系运算符与浮点数比较](Chapter-6/lesson6.7-relational-operators-and-floating-point-comparisons.md)