6.4 — 递增/递减运算符与副作用  
======================================================

[*作者：Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2024年12月29日（首次发布于2007年6月13日）  

变量递增与递减  
----------------  
变量递增（加1）与递减（减1）在编程中极为常见，因此它们拥有专用运算符：  

| 运算符形式         | 符号 | 示例    | 操作描述                         |  
|-------------------|------|---------|----------------------------------|  
| 前递增（pre-increment） | ++   | ++x     | 递增x，然后返回x                 |  
| 前递减（pre-decrement） | --   | --x     | 递减x，然后返回x                 |  
| 后递增（post-increment） | ++   | x++     | 复制x值，递增x，返回复制值       |  
| 后递减（post-decrement） | --   | x--     | 复制x值，递减x，返回复制值       |  

注意每个运算符都有两个版本——前缀版本（运算符在操作数前）和后缀版本（运算符在操作数后）。  

前递增与递减  
----------------  
前缀递增/递减运算符非常直观。首先对操作数进行递增或递减，然后表达式返回操作数的值。例如：  
```cpp
#include <iostream>

int main()
{
    int x { 5 };
    int y { ++x }; // x 先递增到6，x被求值为6，然后6被赋值给y

    std::cout << x << ' ' << y << '\n';
    return 0;
}
```
输出：  
```
6 6
```

后递增与递减  
----------------  
后缀递增/递减运算符更为复杂。首先创建操作数的副本，然后对原操作数（非副本）进行递增或递减，最后返回副本的值。例如：  
```cpp
#include <iostream>

int main()
{
    int x { 5 };
    int y { x++ }; // x 递增到6，原始x的副本被求值为5，然后5被赋值给y

    std::cout << x << ' ' << y << '\n';
    return 0;
}
```
输出：  
```
6 5
```  
让我们详细分析第6行的执行过程：  
1. 创建*x*的临时副本（初始值为5）  
2. 实际*x*从5递增到6  
3. 返回*x*的副本（仍为5）并赋值给*y*  
4. 临时副本被销毁  

最终*y*获得递增前的值5，*x*变为递增后的值6。注意后缀版本需要更多步骤，因此性能通常不如前缀版本。  

更多示例  
----------------  
展示前缀与后缀区别的另一个示例：  
```cpp
#include <iostream>

int main()
{
    int x { 5 };
    int y { 5 };
    std::cout << x << ' ' << y << '\n';
    std::cout << ++x << ' ' << --y << '\n'; // 前缀
    std::cout << x << ' ' << y << '\n';
    std::cout << x++ << ' ' << y-- << '\n'; // 后缀
    std::cout << x << ' ' << y << '\n';

    return 0;
}
```
输出：  
```
5 5
6 4
6 4
6 4
7 3
```  
第8行执行前缀操作：在将值发送到std::cout之前完成递增/递减，因此输出反映更新后的值。  
第10行执行后缀操作：将包含原值的副本发送到std::cout，因此当前行不显示变化。变化在下一次求值时显现。  

何时使用前缀与后缀  
----------------  
多数情况下，前缀与后缀效果相同：  
```cpp
int main()
{
    int x { 0 };
    ++x; // 递增到1
    x++; // 递增到2
    return 0;
}
```  
当两种形式均可使用时，优先选择前缀版本，因其性能更优且不易引发意外。  

> **最佳实践**  
> 优先使用前缀版本。仅在能显著提升代码简洁性或可读性时使用后缀版本。  

副作用（Side effects）  
----------------  
若函数或表达式除了返回值外还有其他可观察效果，则称其具有**副作用（side effect）**。  

常见副作用包括：  
- 修改对象值  
- 执行输入/输出操作  
- 更新图形界面（如启用/禁用按钮）  

大多数情况下副作用是有用的：  
```cpp
x = 5; // 赋值运算符具有修改x的副作用  
++x;   // operator++ 具有递增x的副作用  
std::cout << x; // operator<< 修改控制台状态的副作用  
```  
上述示例中，即使语句执行完毕，赋值运算符仍永久改变*x*的值。同理，operator++ 也会永久改变*x*的值。输出*x*的副作用表现为控制台显示变化。  

> **关键洞察**  
> 赋值运算符、前缀与后缀运算符具有永久改变对象值的副作用。其他运算符（如算术运算符）仅返回值，不修改操作数。  

副作用可能引发求值顺序问题  
----------------  
某些情况下，副作用会导致求值顺序问题。例如：  
```cpp
#include <iostream>

int add(int x, int y)
{
    return x + y;
}

int main()
{
    int x { 5 };
    int value{ add(x, ++x) }; // 未定义行为：这是5+6还是6+6？
    // 取决于编译器对函数参数的求值顺序

    std::cout << value << '\n'; // 可能输出11或12
    return 0;
}
```  
C++标准未规定函数参数的求值顺序。若先求左参数，调用add(5,6)结果为11；若先求右参数，调用add(6,6)结果为12！注意此问题仅因add()的某个参数具有副作用而产生。  

> **旁注**  
> C++标准故意不规定此类细节，以便编译器针对不同架构选择最优实现。  

副作用的顺序性  
----------------  
多数情况下，C++也未规定运算符副作用的应用时机。当同一语句中多次使用具有副作用的对象时，可能导致未定义行为。  

例如表达式`x + ++x`是未定义行为。当`x`初始化为`1`时：  
- Visual Studio和GCC求值为`2 + 2`  
- Clang求值为`1 + 2`  

这是由于编译器应用*x*递增副作用的时机不同所致。即使C++标准明确某些情况，历史上仍存在大量编译器错误。通过确保具有副作用的变量在单条语句中最多使用一次，可避免此类问题。  

> **警告**  
> C++未定义函数参数或运算符操作数的求值顺序。  

> **警告**  
> 不要在单条语句中多次使用具有副作用的变量，否则结果可能未定义。简单赋值表达式（如`x = x + y`，等价于`x += y`）除外。  

[下一课 6.5 — 逗号运算符](Chapter-6/lesson6.5-the-comma-operator.md)  
[返回主页](/)  
[上一课 6.3 — 取模与幂运算](Chapter-6/lesson6.3-remainder-and-exponentiation.md)