7.3 — 局部变量  
================================================

[*作者：Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2024年6月9日（首次发布于2015年3月23日）  

在课程[2.5 — 局部作用域简介](Chapter-2/lesson2.5-introduction-to-local-scope.md)中，我们介绍了**局部变量（local variables）**——即定义在函数内部（包括函数参数）的变量。  

事实上，C++并没有通过单一属性来定义变量是否为局部变量。相反，局部变量通过若干不同属性区别于其他（非局部）变量。我们将在本章及后续课程中探讨这些属性。  

在课程[2.5 — 局部作用域简介](Chapter-2/lesson2.5-introduction-to-local-scope.md)中，我们还介绍了作用域的概念。标识符的**作用域（scope）**决定了其在源代码中的可访问范围。当标识符可访问时称为**在作用域内（in scope）**，不可访问时称为**超出作用域（out of scope）**。作用域是编译期属性，尝试使用超出作用域的标识符将导致编译错误。  

局部变量具有块作用域  
----------------  

局部变量具有**块作用域（block scope）**，即从定义点开始到所在块结束为止均处于作用域内。  

> **相关内容**  
> 若需回顾块的概念，请复习课程[7.1 — 复合语句（块）](Chapter-7/lesson7.1-compound-statements-blocks.md)。  

```
int main()
{
    int i { 5 }; // i在此处进入作用域
    double d { 4.0 }; // d在此处进入作用域

    return 0;
} // d和i在此处超出作用域
```

虽然函数参数并非定义在函数体内，但通常可视为函数体块作用域的一部分。  

```
int max(int x, int y) // x和y在此处进入作用域
{
    // 将x和y中较大值赋给max
    int max{ (x > y) ? x : y }; // max在此处进入作用域

    return max;
} // max、y和x在此处超出作用域
```

同一作用域内变量名必须唯一  
----------------  

同一作用域内变量名必须唯一，否则任何对该名称的引用都将产生歧义。考虑以下程序：  

```
void someFunction(int x)
{
    int x{}; // 与函数参数x命名冲突导致编译失败
}

int main()
{
    return 0;
}
```

上述程序无法编译，因为函数体内定义的变量`x`与函数参数`x`同名且处于同一块作用域。  

局部变量具有自动存储期  
----------------  

变量的**存储期（storage duration）**（通常简称为**持续期（duration）**）决定了变量创建（实例化）和销毁的规则。多数情况下，变量的存储期直接决定其**生命周期（lifetime）**。  

> **相关内容**  
> 生命周期概念详见课程[2.5 — 局部作用域简介](Chapter-2/lesson2.5-introduction-to-local-scope.md)。  

局部变量具有**自动存储期（automatic storage duration）**，即在定义点创建，在所在块结束时销毁。例如：  

```
int main()
{
    int i { 5 }; // i在此处创建并初始化
    double d { 4.0 }; // d在此处创建并初始化

    return 0;
} // d和i在此处销毁
```

因此，局部变量有时也被称为**自动变量（automatic variables）**。  

嵌套块中的局部变量  
----------------  

局部变量可定义在嵌套块中，其行为与函数体块中的局部变量相同：  

```
int main() // 外部块
{
    int x { 5 }; // x进入作用域并在此处创建

    { // 嵌套块
        int y { 7 }; // y进入作用域并在此处创建
    } // y超出作用域并在此处销毁

    // 此处不可访问y（已超出作用域）

    return 0;
} // x超出作用域并在此处销毁
```

上述示例中，变量`y`定义在嵌套块内。其作用域从定义点延伸至嵌套块结束，生命周期同理。由于`y`的作用域限定在内部块，无法在外部块的任何位置访问。  

注意嵌套块被视为外部块作用域的一部分。因此外部块定义的变量*可以*在嵌套块内访问：  

```
#include <iostream>

int main()
{ // 外部块

    int x { 5 }; // x进入作用域并在此处创建

    { // 嵌套块
        int y { 7 }; // y进入作用域并在此处创建

        // 此处x和y均在作用域内
        std::cout << x << " + " << y << " = " << x + y << '\n';
    } // y超出作用域并在此处销毁

    // 此处不可访问y（已超出作用域）

    return 0;
} // x超出作用域并在此处销毁
```

局部变量无链接性  
----------------  

标识符另有**链接性（linkage）**属性，决定了不同作用域中同名的声明是否指向同一对象（或函数）。  

局部变量无链接性。每个无链接性的标识符声明都指向独立的对象或函数。例如：  

```
int main()
{
    int x { 2 }; // 局部变量，无链接性

    {
        int x { 3 }; // 该x声明指向与前一个x不同的对象
    }

    return 0;
}
```

作用域与链接性看似相似，但作用域决定单个标识符声明在代码中的可见范围，链接性决定多个同名声明是否指向同一对象。  

> **相关内容**  
> 嵌套块中出现同名变量的情况详见课程[7.5 — 变量遮蔽（名称隐藏）](Chapter-7/lesson7.5-variable-shadowing-name-hiding.md)。  

在局部变量上下文中，链接性并不重要，但我们将在后续课程中详细讨论。  

变量应定义在最受限的作用域  
----------------  

若变量仅用于嵌套块内，应定义在该嵌套块中：  

```
#include <iostream>

int main()
{
    // 不要在此处定义y

    {
        // y仅在此块内使用，故定义于此
        int y { 5 };
        std::cout << y << '\n';
    }

    // 否则y仍可能在此处被使用（实际不需要）

    return 0;
}
```

通过限制变量作用域，可降低程序复杂度（减少活动变量数量），并更易观察变量使用情况。定义在块内的变量只能在该块（或嵌套块）中使用，这有助于提高代码可读性。  

若外部块需要某变量，则需在外部块声明：  

```
#include <iostream>

int main()
{
    int y { 5 }; // 声明y于此，因后续外部块需要

    {
        int x{};
        std::cin >> x;

        // 若在此处定义y（紧接首次使用前）...
        if (x == 4)
            y = 4;
    } // ...y将在此处销毁

    std::cout << y; // 此处仍需y存在

    return 0;
}
```

此例展示了少数需要在首次使用前提前声明变量的场景。  

新手开发者有时会纠结是否应专门创建嵌套块来限制变量作用域（强制其提前超出作用域/销毁）。这样做虽简化了该变量，但会使整体函数更长更复杂。通常这种取舍并不值得。若创建嵌套块仅为限制代码作用域，可能更适合将相关代码移至独立函数。  

> **最佳实践**  
> 在现有的最受限作用域中定义变量。避免创建仅用于限制变量作用域的新块。  

测验时间  
----------------  

**问题1**  
编写程序要求用户输入两个整数`smaller`和`larger`。若第二个数更小，使用代码块和临时变量交换两值。随后打印`smaller`和`larger`的值，代码中需注释各变量销毁位置。注意：无论输入顺序如何，`smaller`应保存较小值，`larger`保存较大值。  

程序输出示例如下：  

```
输入整数：4  
输入更大整数：2  
正在交换值  
较小值为2  
较大值为4  
```

  

```
#include <iostream>

int main()
{
    std::cout << "Enter an integer: ";
    int smaller{};
    std::cin >> smaller;

    std::cout << "Enter a larger integer: ";
    int larger{};
    std::cin >> larger;

    // 用户输入错误时
    if (smaller > larger)
    {
        // 交换smaller和larger的值
        std::cout << "Swapping the values\n";

        int temp{ larger };
        larger = smaller;
        smaller = temp;
    } // temp在此处销毁

    std::cout << "The smaller value is: " << smaller << '\n';
    std::cout << "The larger value is: " << larger << '\n';

    return 0;
} // smaller和larger在此处销毁
```

未来可使用`<utility>`头文件中的`std::swap()`交换变量值：  

```
int temp{ larger };
larger = smaller;
smaller = temp;

// 等同于
std::swap(larger, smaller);
```

**问题2**  
变量作用域、持续期与生命周期有何区别？默认情况下，局部变量的作用域和持续期类型及其含义是什么？  

  

变量的作用域决定其在源代码中的可访问范围。持续期定义变量创建和销毁的规则。生命周期是变量实际存在的时间。  

局部变量具有块作用域，即从定义点至所在块结束均可访问。  

局部变量具有自动持续期，即在定义点创建，在所在块结束时销毁。  

[下一课 7.4 全局变量简介](Chapter-7/lesson7.4-introduction-to-global-variables.md)  
[返回主页](/)    
[上一课 7.2 用户定义命名空间与作用域解析运算符](Chapter-7/lesson7.2-user-defined-namespaces-and-the-scope-resolution-operator.md)