7.9 — 内联函数与变量
=====================================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")
2007年7月30日 下午3:16（PDT）
2025年1月18日

考虑需要编写代码执行离散任务（如读取用户输入、输出到文件或计算特定值）的场景。实现此类代码时，您有两种基本选择：
1. 将代码作为现有函数的一部分（称为"就地（in-place）"或"内联（inline）"编写）。
2. 创建新函数（可能包含子函数）处理任务。

将代码放入新函数具有诸多优势，因为小型函数：
* 在整体程序上下文中更易于阅读和理解。
* 更易于复用，函数天然具有模块化特性。
* 更易于更新，代码只需在单处修改。

然而使用新函数的缺点是：每次调用函数时会产生一定的性能开销（overhead）。参考以下示例：
```
#include <iostream>

int min(int x, int y)
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```
当遇到`min()`调用时，CPU必须存储当前执行指令的地址（以便后续返回定位）及各类CPU寄存器的值（用于返回时恢复）。接着实例化并初始化参数`x`和`y`，随后执行路径跳转至`min()`函数代码。函数结束时，程序需跳回函数调用点并复制返回值以供输出。每次函数调用均需执行此过程。  
为完成任务（此处指函数调用）所必须进行的额外设置、支持及清理工作称为**开销（overhead）**。

对于大型和/或执行复杂任务的函数，函数调用的开销通常远小于函数运行时间。但对于小型函数（如上述`min()`），开销成本可能超过实际执行函数代码所需时间！当小型函数被频繁调用时，使用函数可能比就地编写相同代码造成显著的性能损失。

### 内联展开（Inline expansion）
幸运的是，C++编译器可通过**内联展开（inline expansion）**避免此类开销：该过程用被调用函数的定义代码直接替换函数调用。

例如若编译器展开上例中的`min()`调用，结果代码如下：
```
#include <iostream>

int main()
{
    std::cout << ((5 < 6) ? 5 : 6) << '\n';
    std::cout << ((3 < 2) ? 3 : 2) << '\n';
    return 0;
}
```
注意：两次`min()`函数调用被替换为`min()`函数体内的代码（参数值已代入形参）。这既避免了调用开销，又保留了代码结果。

### 内联代码的性能表现
内联展开不仅能消除函数调用成本，还可让编译器更高效地优化结果代码。例如表达式`((5 < 6) ? 5 : 6)`现为常量表达式，编译器可进一步将`main()`中首条语句优化为`std::cout << 5 << '\n';`。

但内联展开也有潜在代价：若被展开的函数体指令数超过被替换的函数调用指令数，每次展开都会导致可执行文件增大。较大的可执行文件通常更慢（因难以适配内存缓存）。

判断函数是否适合内联（即函数调用开销的消除是否优于可执行文件增大）并非易事。内联展开可能提升性能、降低性能或不影响性能，具体取决于函数调用成本、函数大小及其他可执行的优化措施。

内联展开最适合简单短小的函数（如不超过几条语句），尤其当单次函数调用可能执行多次时（如循环内的函数调用）。

### 内联展开的发生时机
所有函数分为两类，其调用：
* 可被展开（大多数函数属此类）。
* 不可展开。

多数函数属"可展开"类：当有益时其函数调用可被展开。对此类函数，现代编译器会评估每个函数及函数调用，决定特定调用是否受益于内联展开。编译器可能选择不展开、部分展开或全部展开某函数的所有调用。

> **提示**  
> 现代优化编译器自主决定函数的内联展开时机。

最常见的不可内联函数是定义位于其他翻译单元（translation unit）的函数。由于编译器无法看到此类函数定义，故不知如何替换函数调用！

### inline关键字的演变
历史上编译器要么无法判断内联展开的收益，要么判断能力有限。因此C++提供`inline`关键字，初衷是向编译器提示某函数可能受益于内联展开。

使用`inline`关键字声明的函数称为**内联函数（inline function）**。

示例如下：
```
#include <iostream>

inline int min(int x, int y) // inline关键字表示此为内联函数
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```
但在现代C++中，`inline`不再用于请求内联展开，原因如下：
* 使用`inline`请求内联展开属于过早优化（premature optimization），滥用可能损害性能。
* `inline`仅是辅助编译器决定内联展开位置的提示。编译器可完全忽略该请求（实际常如此），也可对未使用`inline`的函数执行内联展开（作为常规优化）。
* `inline`关键字的粒度控制不当。我们在函数定义处使用`inline`，但内联展开实际按每次调用决定。某些调用适合展开而另一些不适合，但语法无法影响此决策。

现代优化编译器通常比人类更擅长判断哪些函数调用应内联。因此编译器可能忽略或弱化任何使用`inline`请求函数内联的行为。

> **最佳实践**  
> 勿用`inline`关键字请求函数的内联展开。

### inline关键字的现代含义
前文提到：不应在头文件中实现（具外部链接的）函数，因为头文件被多个.cpp文件包含时，函数定义会复制到多个.cpp文件。编译后链接器将因违反单一定义规则（one-definition rule, ODR）而报错。

现代C++中，`inline`的含义演变为"允许多重定义"。因此内联函数允许在多个翻译单元中定义（不违反ODR）。

内联函数有两个主要要求：
* 编译器需在使用该函数的每个翻译单元中看到完整定义（仅前置声明不足）。每个翻译单元仅能存在一个定义，否则导致编译错误。
* 若提供前置声明，定义可出现在使用点之后。但编译器需看到定义后才能执行内联展开（故声明与定义间的调用点可能无法内联）。
* 每个内联函数（默认具外部链接）的定义必须完全相同，否则导致未定义行为。

> **规则**  
> 编译器需在使用内联函数的任意位置看到其完整定义，且所有（具外部链接的）内联函数定义必须完全相同（否则导致未定义行为）。

> **关联内容**  
> 内部链接详见课程[7.6 — 内部链接](Chapter-7/lesson7.6-internal-linkage.md)，外部链接详见[7.7 — 外部链接与变量前置声明](Chapter-7/lesson7.7-external-linkage-and-variable-forward-declarations.md)。

链接器会将标识符的所有内联函数定义合并为单一定义（仍满足单一定义规则要求）。

示例如下：
main.cpp:
```
#include <iostream>

double circumference(double radius); // 前置声明

inline double pi() { return 3.14159; }

int main()
{
    std::cout << pi() << '\n';
    std::cout << circumference(2.0) << '\n';

    return 0;
}
```
math.cpp
```
inline double pi() { return 3.14159; }

double circumference(double radius)
{
    return 2.0 * pi() * radius;
}
```
注意：两个文件均有`pi()`函数定义——但因标记为`inline`，此做法可接受，链接器将执行去重。若移除两处定义的`inline`关键字，将违反ODR（禁止非内联函数的重复定义）。

> **选读内容**  
> 虽然`inline`的历史用途（执行内联展开）与现代用途（允许多重定义）看似无关，实则紧密关联。  
> 
> 历史上假设存在适合内联展开的简单函数，我们将其标记为`inline`。为实际展开函数调用，编译器需在使用该函数的每个翻译单元中看到完整定义——否则无法确定如何替换调用。其他翻译单元定义的函数无法在当前编译单元内联展开。  
> 
> 简单的内联函数常需在多个翻译单元使用。但根据前述要求将函数定义复制到各翻译单元后，会违反ODR"每个程序仅允许单一函数定义"的要求。最佳解决方案是豁免内联函数的ODR限制。  
> 
> 因此历史上我们用`inline`请求内联展开，而ODR豁免是为实现跨翻译单元内联展开的必要条件。现代用法中，我们用`inline`实现ODR豁免，而将内联展开交由编译器处理。内联函数的机制未变，变的是我们的关注点。  
> 
> 您可能好奇为何内联函数可豁免ODR而非内联函数仍需遵守。对于非内联函数，我们预期函数仅定义一次（在单一翻译单元）。若链接器遇到多个非内联函数定义，会视为两个独立函数的命名冲突。而调用具有多重定义的非内联函数将导致调用目标不明确。但对于内联函数，所有定义均被视为同一函数，故该翻译单元内的调用可内联展开。若调用未内联展开，多重定义中任一皆可匹配调用目标——不存在歧义！

内联函数通常定义在头文件中，通过`#include`引入需看到完整定义的代码文件。这确保标识符的所有内联定义完全相同。
pi.h:
```
#ifndef PI_H
#define PI_H

inline double pi() { return 3.14159; }

#endif
```
main.cpp:
```
#include "pi.h" // 此处引入pi()定义
#include <iostream>

double circumference(double radius); // 前置声明

int main()
{
    std::cout << pi() << '\n';
    std::cout << circumference(2.0) << '\n';

    return 0;
}
```
math.cpp
```
#include "pi.h" // 此处引入pi()定义

double circumference(double radius)
{
    return 2.0 * pi() * radius;
}
```
这对**仅头文件库（header-only libraries）**特别有用——此类库由一个或多个实现功能的头文件组成（不含.cpp文件）。仅头文件库因无需向项目添加源文件且无需链接而流行：仅需`#include`库头文件即可使用。

> **关联内容**  
> 我们在课程[8.15 — 全局随机数（Random.h）](Chapter-8/lesson8.15-global-random-numbers-random-h.md)展示了内联在随机数生成头文件库中的实际应用。

> **进阶阅读**  
> 以下函数隐式内联：  
> * 类、结构体或联合类型内定义的函数（[14.3 — 成员函数](Chapter-14/lesson14.3-member-functions.md)）。  
> * 常量表达式/即时函数（constexpr/consteval functions）（[F.1 — 常量表达式函数](Chapter-F/lessonF.1-constexpr-functions.md)）。  
> * 函数模板隐式实例化的函数（[11.7 — 函数模板实例化](Chapter-11/lesson11.7-function-template-instantiation.md)）。

通常除非在头文件中定义（且非隐式内联），否则不应将函数或变量标记为`inline`。

> **最佳实践**  
> 除非有明确理由（如在头文件中定义函数或变量），否则避免使用`inline`关键字。

### 为何不将所有函数内联并定义在头文件？
主要原因是这会显著增加编译时间。当头文件中的内联函数被`#include`到源文件时，函数定义将作为翻译单元的一部分编译。被6个翻译单元包含的内联函数会编译6次定义（链接器在去重前）。相反，源文件中定义的函数无论其前置声明被包含多少次，定义仅编译一次。

其次，若源文件中的函数变更，仅该文件需重新编译。当头文件的内联函数变更时，所有包含该头文件的代码文件（直接或间接包含）均需重新编译。大型项目中可能引发级联重编译，造成严重影响。

### C++17的内联变量（Inline variables）
上例中`pi()`以返回常量值的函数实现。若`pi`实现为（常量）变量则更直观，但C++17之前存在障碍和效率问题。

C++17引入**内联变量（inline variables）**，允许在多个文件中定义。内联变量工作机制类似内联函数，且要求相同（编译器在使用处必须看到完全相同的完整定义）。

> **进阶阅读**  
> 以下变量隐式内联：  
> * 静态常量表达式数据成员（[15.6 — 静态成员变量](Chapter-15/lesson15.6-static-member-variables.md)）。  
> 
> 注意：与constexpr函数不同，constexpr变量默认不内联（上述情况除外）！

我们将在课程[7.10 — 跨文件共享全局常量（使用内联变量）](Chapter-7/lesson7.10-sharing-global-constants-across-multiple-files-using-inline-variables.md)说明内联变量的常见用法。

[下一课 7.10 跨文件共享全局常量（使用内联变量）](Chapter-7/lesson7.10-sharing-global-constants-across-multiple-files-using-inline-variables.md)  
[返回主页](/)  
[上一课 7.8 为何（非const）全局变量有害](Chapter-7/lesson7.8-why-non-const-global-variables-are-evil.md)