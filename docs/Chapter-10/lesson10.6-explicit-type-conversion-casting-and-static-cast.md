10.6 — 显式类型转换（casting）与 static_cast  
===========================================================

[*作者：Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2025年3月4日（首次发布于2015年4月16日）  

在课程[10.1 — 隐式类型转换](Chapter-10/lesson10.1-implicit-type-conversion.md)中，我们讨论了编译器使用隐式类型转换将值从一种数据类型转换为另一种数据类型。当需要将值从较窄类型数值提升（numeric promotion）到较宽类型时，使用隐式类型转换是合适的。许多C++新手常犯如下错误：  
```
double d = 10 / 4; // 执行整数除法，用值2.0初始化d
```  
由于`10`和`4`均为`int`类型，将执行整数除法，表达式求值为`int`值`2`。随后该值在用于初始化变量`d`前进行数值转换，转为`double`值`2.0`。这显然不符合预期。  

对于字面量操作数，可将一个或两个整数字面量替换为双精度字面量以触发浮点除法：  
```
double d = 10.0 / 4.0; // 执行浮点除法，用值2.5初始化d
```  
但若使用变量而非字面量时如何处理？考虑以下情形：  
```
int x { 10 };
int y { 4 };
double d = x / y; // 执行整数除法，用值2.0初始化d
```  
由于此处使用整数除法，变量`d`最终将获得`2.0`的值。如何告知编译器在此情况下使用浮点除法而非整数除法？字面量后缀无法用于变量，我们需要某种方式将变量操作数转换为浮点类型以触发浮点除法。  

C++提供了多种**类型转换运算符**（通常称为**转换**），允许程序员要求编译器执行类型转换。由于转换是程序员的显式请求，这种类型转换常被称为**显式类型转换**（与编译器自动执行的隐式类型转换相对）。  

类型转换  
----------------  
C++支持5种转换方式：`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`以及C风格转换。前四种有时称为**命名转换**。  

| 转换类型 | 描述 | 安全性 |  
| --- | --- | --- |  
| `static_cast` | 在相关类型间执行编译期类型转换 | 安全 |  
| `dynamic_cast` | 在多态（继承）层次结构中执行指针或引用的运行时类型转换 | 安全 |  
| `const_cast` | 添加或移除const限定 | 仅添加const时安全 |  
| `reinterpret_cast` | 将类型的位级表示重新解释为另一种类型 | 不安全 |  
| C风格转换 | 组合使用`static_cast`、`const_cast`或`reinterpret_cast` | 不安全 |  

每种转换的运作方式相同。转换接受一个表达式（求值为值或对象）和目标类型作为输入，返回转换结果。  

C风格转换  
----------------  
在标准C编程中，转换通过`运算符()`实现，将目标类型名置于括号内，待转换值紧接在右括号后。在C++中，这种转换称为**C风格转换**，常见于从C转换而来的代码中。例如：  
```
#include <iostream>

int main()
{
    int x { 10 };
    int y { 4 };

    std::cout << (double)x / y << '\n'; // 将x以C风格转换为double

    return 0;
}
```  
上述程序中，我们使用C风格转换告知编译器将`x`转为`double`。由于`operator/`的左操作数现在求值为浮点值，右操作数也将转换为浮点值，除法将使用浮点运算而非整数运算。  

C++还提供另一种C风格转换形式——**函数风格转换**，其形似函数调用：  
```
    std::cout << double(x) / y << '\n'; // 将x以函数风格转换为double
```  
函数风格转换更易于识别被转换对象（类似于标准函数参数）。  

现代C++中通常避免使用C风格转换有两个主要原因：  
1. C风格转换表面上是单一转换，实际可能执行多种不同转换（包括静态转换、常量转换或重新解释转换），这导致代码难以理解且存在误用风险  
2. C风格转换仅由类型名、括号和变量构成，难以识别和搜索  

命名转换则易于识别、用途明确、功能受限，若误用会产生编译错误。  

> **最佳实践**  
> 避免使用C风格转换  

static_cast 应优先用于大多数值转换  
----------------  
**静态转换**通过`static_cast`关键字实现，用于将值显式转换为另一类型。例如将`char`转为`int`以便`std::cout`以整数形式输出：  
```
#include <iostream>

int main()
{
    char c { 'a' };
    std::cout << static_cast<int>(c) << '\n'; // 输出97而非a

    return 0;
}
```  
执行静态转换时，以`static_cast`关键字开头，目标类型置于尖括号中，待转换表达式置于括号内。语法形似调用名为`static_cast<类型>()`的函数。  

以下示例演示如何用`static_cast`解决引言中的问题：  
```
#include <iostream>

int main()
{
    int x { 10 };
    int y { 4 };

    // 将x静态转换为double以执行浮点除法
    std::cout << static_cast<double>(x) / y << '\n'; // 输出2.5

    return 0;
}
```  
`static_cast<double>(x)`返回包含转换值`10.0`的临时`double`对象，作为浮点除法的左操作数。  

静态转换具有两个重要特性：  
1. 提供编译期类型检查，若转换不可行将产生编译错误  
2. 功能弱于C风格转换，阻止某些危险转换（如需要重新解释或丢弃const的转换）  

> **最佳实践**  
> 需要类型转换时优先使用`static_cast`  

使用 static_cast 显式窄化转换  
----------------  
当进行潜在不安全的隐式窄化转换时，编译器常发出警告。例如：  
```
int i { 48 };
char ch = i; // 隐式窄化转换
```  
将`int`（2或4字节）转换为`char`（1字节）存在溢出风险，编译器通常发出警告。使用列表初始化时编译器将报错。  

通过静态转换可显式告知编译器接受该转换：  
```
int i { 48 };
char ch { static_cast<char>(i) }; // 显式int到char转换
```  
此时初始化`ch`不会产生类型不匹配警告。  

另一示例：  
```
int i { 100 };
i = i / 2.5;
```  
显式转换可消除警告：  
```
int i { 100 };
i = static_cast<int>(i / 2.5);
```  

转换 vs 初始化临时对象  
----------------  
将变量`x`转换为`int`有两种常规方法：  
1. `static_cast<int>(x)`：返回直接初始化的临时`int`对象  
2. `int { x }`：创建直接列表初始化的临时`int`对象  

主要区别：  
1. `int { x }`使用列表初始化，禁止窄化转换。转换时若可能丢失数据，应允许该操作  
2. `static_cast`更清晰表明转换意图，提高代码安全性和可读性  
3. 直接列表初始化仅允许单字类型名  

例如：  
```
std::cout << double{x} / y << '\n'; // 32位int可行，64位int将窄化
```  
在64位架构下转换`int`为`double`是窄化转换，列表初始化将阻止编译。  

> **最佳实践**  
> 需要转换时优先使用`static_cast`而非临时对象初始化  

测验  
----------------  
**问题1**  
隐式与显式类型转换的区别？  
  
<details><summary>答案</summary>隐式转换在需要某类型时自动执行；显式转换通过类型转换运算符主动请求。</details>  

[下一课 10.7 类型定义与类型别名](Chapter-10/lesson10.7-typedefs-and-type-aliases.md)  
[返回主页](/)  
[上一课 10.5 算术转换](Chapter-10/lesson10.5-arithmetic-conversions.md)