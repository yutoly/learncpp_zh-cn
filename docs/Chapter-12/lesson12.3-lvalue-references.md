12.3 — 左值引用（Lvalue references）
=========================

[*作者：Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2024年11月11日（首次发布于2007年7月16日）  

在C++中，**引用（reference）**是现有对象的别名。引用一旦定义，对引用的所有操作都将作用于被引用的对象。这意味着我们可以通过引用读取或修改被引用对象。尽管引用初看可能显得多余，但它们在C++中无处不在（后续课程将展示具体示例）。  

> **核心洞察**  
> 引用本质上与被引用对象完全等同。  

您也可以创建函数引用，不过这种情况较少见。现代C++包含两种引用类型：左值引用（lvalue references）和右值引用（rvalue references）。本章重点讨论左值引用。  

> **相关内容**  
> 本课涉及左值和右值的概念，建议先复习[12.2 — 值类别（左值与右值）](Chapter-12/lesson12.2-value-categories-lvalues-and-rvalues.md)。右值引用将在移动语义章节（[第22章](https://www.learncpp.com#Chapter22)）详细讨论。  

左值引用类型  
----------------  

**左值引用**（在C++11前是唯一的引用类型，通常简称为"引用"）作为现有左值（如变量）的别名。  

与对象类型决定其存储值类似，引用类型决定其可引用的对象类型。左值引用类型可通过类型说明符中的单个&符号识别：  
```
// 常规类型
int        // 普通int类型（非引用）
int&       // int对象的左值引用
double&    // double对象的左值引用
const int& // const int对象的左值引用
```  

例如，`int&`表示int对象的左值引用类型，`const int&`表示const int对象的左值引用类型。  

指定引用类型的语法（如`int&`）称为**引用类型**，被引用的类型（如`int`）称为**被引用类型**。  

> **术语说明**  
> 左值引用分为两类：  
> * 指向非const的左值引用通常简称为"左值引用"，也可称为**非const左值引用**（因其未使用`const`关键字定义）  
> * 指向const的左值引用通常称为**const左值引用**  

本章重点讨论非const左值引用，const左值引用将在下节课（[12.4 — const左值引用](Chapter-12/lesson12.4-lvalue-references-to-const.md)）讲解。  

左值引用变量  
----------------  

使用左值引用类型可创建左值引用变量。**左值引用变量**是作为左值（通常为其他变量）引用的变量。  

创建左值引用变量时，只需用左值引用类型定义变量：  
```
#include <iostream>

int main()
{
    int x { 5 };    // x是普通整型变量
    int& ref { x }; // ref现在是变量x的别名

    std::cout << x << '\n';   // 输出x的值（5）
    std::cout << ref << '\n'; // 通过ref输出x的值（5）

    return 0;
}
```  

上述示例中，`int&`类型将`ref`定义为int的左值引用，并用左值表达式`x`初始化。此后`ref`与`x`可互换使用。程序输出：  
```
5
5
```  

编译器视角中，&符号附着于类型名（`int& ref`）或变量名（`int &ref`）的写法无区别，属风格选择。现代C++程序员倾向于将&附于类型，更清晰地表明引用是类型信息的一部分。  

> **最佳实践**  
> 定义引用时，将&符号置于类型旁（而非变量名旁）。  

> **进阶阅读**  
> 对指针熟悉的读者需注意：此处的&符号不表示"取地址"，而是"左值引用"。  

通过非const左值引用修改值  
----------------  

除读取被引用对象值外，我们还可通过非const引用修改其值：  
```
#include <iostream>

int main()
{
    int x { 5 }; // 普通整型变量
    int& ref { x }; // ref现为x的别名

    std::cout << x << ref << '\n'; // 输出55

    x = 6; // x现为6

    std::cout << x << ref << '\n'; // 输出66

    ref = 7; // 被引用对象（x）现为7

    std::cout << x << ref << '\n'; // 输出77

    return 0;
}
```  

输出结果：  
```
55
66
77
```  

示例中`ref`是`x`的别名，因此通过`x`或`ref`均可修改其值。  

引用初始化  
----------------  

与常量类似，所有引用必须初始化。引用通过**引用初始化**方式进行初始化。  
```
int main()
{
    int& invalidRef;   // 错误：引用必须初始化

    int x { 5 };
    int& ref { x }; // 正确：int引用绑定到int变量

    return 0;
}
```  

当引用被对象（或函数）初始化时，称为**绑定（bound）**到该对象（或函数）。此过程称为**引用绑定**。被引用对象（或函数）有时称为**被引用体（referent）**。  

非const左值引用只能绑定到*可修改*的左值：  
```
int main()
{
    int x { 5 };
    int& ref { x };         // 正确：非const左值引用绑定到可修改左值

    const int y { 5 };
    int& invalidRef { y };  // 无效：非const左值引用不能绑定到不可修改左值
    int& invalidRef2 { 0 }; // 无效：非const左值引用不能绑定到右值

    return 0;
}
```  

> **核心洞察**  
> 若允许非const左值引用绑定到不可修改左值或右值，将可能通过引用修改这些值，违反其const属性。  

禁止创建`void`的左值引用（无实际意义）。即使引用类型（如`int&`）与被绑定对象类型（如`int`）不完全匹配，此处也不进行类型转换——类型差异通过引用初始化过程处理。  

引用通常仅绑定匹配类型对象  
----------------  

多数情况下，引用仅绑定到与其被引用类型匹配的对象（继承相关情况例外）。若尝试绑定到类型不匹配对象，编译器将尝试隐式转换对象为被引用类型后进行绑定。  

> **核心洞察**  
> 由于转换结果是右值，而非const左值引用不能绑定到右值，因此尝试绑定到类型不匹配对象将导致编译错误。  

```
int main()
{
    int x { 5 };
    int& ref { x };            // 正确：被引用类型（int）匹配初始化式类型

    double d { 6.0 };
    int& invalidRef { d };     // 无效：double到int的窄化转换被列表初始化禁止
    double& invalidRef2 { x }; // 无效：非const左值引用不能绑定到右值（x转换double的结果）

    return 0;
}
```  

引用不可重绑定（reseated）  
----------------  

C++中的引用初始化后不可**重绑定**（即不能改为引用其他对象）。  

新手常尝试通过赋值使引用指向其他变量，这将编译运行但不符合预期。考虑以下程序：  
```
#include <iostream>

int main()
{
    int x { 5 };
    int y { 6 };

    int& ref { x }; // ref现为x的别名
    
    ref = y; // 将y的值（6）赋给x（ref引用的对象）
    // 该行不会使ref改为引用变量y！

    std::cout << x << '\n'; // 用户预期输出5

    return 0;
}
```  

结果输出：  
```
6
```  

当引用在表达式中求值时，它解析为被引用对象。因此`ref = y`不会改变ref的引用目标，而是等价于`x = y`。由于`y`值为6，`x`被赋值为6。  

引用作用域与生存期  
----------------  

引用变量遵循与普通变量相同的作用域和生存期规则：  
```
#include <iostream>

int main()
{
    int x { 5 }; // 普通整型
    int& ref { x }; // 变量x的引用

     return 0;
} // x和ref在此销毁
```  

引用与被引用体的生存期独立  
----------------  

除下节课将讨论的例外情况外，引用的生存期与被引用体的生存期相互独立：  
* 引用可能在被引用体之前销毁  
* 被引用体可能在引用之前销毁  

当引用先被销毁时，被引用体不受影响。以下程序演示此情况：  
```
#include <iostream>

int main()
{
    int x { 5 };

    {
        int& ref { x };   // ref是x的引用
        std::cout << ref << '\n'; // 输出ref的值（5）
    } // ref在此销毁——x不受影响

    std::cout << x << '\n'; // 输出x的值（5）

    return 0;
} // x在此销毁
```  

输出结果：  
```
5
5
```  

当`ref`销毁时，变量`x`继续存在。  

悬垂引用（Dangling references）  
----------------  

当被引用体在引用之前销毁时，引用将指向不存在的对象，称为**悬垂引用**。访问悬垂引用导致未定义行为。  

实际案例将在[12.12 — 返回引用与返回地址](Chapter-12/lesson12.12-return-by-reference-and-return-by-address.md)中展示。  

引用非对象  
----------------  

引用在C++中并非对象。引用不一定需要存在或占用存储空间。编译器会尽可能优化引用，将其替换为被引用体。但并非总能优化，此时引用可能需要存储空间。  

因此"引用变量"的术语并不准确，因变量是具有名称的对象，而引用并非对象。由于引用非对象，它们不能用于需要对象的场合（例如不能有引用的引用）。若需要可重绑定的引用对象，可使用`std::reference_wrapper`（将在[23.3 — 聚合](Chapter-23/lesson23.3-aggregation.md)中讲解）。  

> **补充说明**  
> 考虑以下变量：  
> ```
> int var{};
> int& ref1{ var };  // 绑定到var的左值引用
> int& ref2{ ref1 }; // 绑定到var的左值引用
> ```  
> 由于`ref2`（引用）用`ref1`（引用）初始化，可能误认为`ref2`是引用的引用。实际当`ref1`在表达式（如初始化式）中求值时，它解析为`var`。因此`ref2`只是普通的左值引用（类型为`int&`），绑定到`var`。  

引用的引用（指向`int`）语法应为`int&&`——但由于C++不支持引用的引用，此语法在C++11中被重新用于表示右值引用（详见[22.2 — 右值引用](Chapter-22/lesson22.2-rvalue-references.md)）。  

> **作者提示**  
> 若目前觉得引用用处不大，请勿担心。引用应用广泛，主要用途将在[12.5 — 按左值引用传递](Chapter-12/lesson12.5-pass-by-lvalue-reference.md)和[12.6 — 按const左值引用传递](Chapter-12/lesson12.6-pass-by-const-lvalue-reference.md)中讲解。  

测验时间  
----------------  

**问题1**  
预测以下程序输出结果（不编译程序）：  
```
#include <iostream>

int main()
{
    int x{ 1 };
    int& ref{ x };

    std::cout << x << ref << '\n';

    int y{ 2 };
    ref = y;
    y = 3;

    std::cout << x << ref << '\n';

    x = 4;

    std::cout << x << ref << '\n';

    return 0;
}
```  

  
<details><summary>答案</summary>  
11  
22  
44  
由于`ref`绑定到`x`，`x`和`ref`等价，始终输出相同值。`ref = y`将`y`的值（2）赋给`ref`，不会改变`ref`的引用目标。后续`y = 3`仅修改`y`。</details>  

[下一课 12.4 const左值引用](Chapter-12/lesson12.4-lvalue-references-to-const.md)  
[返回主页](/)  
[上一课 12.2 值类别（左值与右值）](Chapter-12/lesson12.2-value-categories-lvalues-and-rvalues.md)