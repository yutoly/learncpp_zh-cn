O.4 — 二进制与十进制整数的相互转换  
================================================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2007年6月17日 上午11:14（太平洋夏令时）  
2025年2月18日  

以十进制整数值5623为例，我们直观理解其含义为(5×1000) + (6×100) + (2×10) + (3×1)。由于十进制有10个数字，左侧每位数字的权重递增10倍。  

二进制数原理相同，但因仅有0和1两个数字，每位权重递增2倍。为提升可读性，十进制常用逗号分隔（如1,427,435），二进制则常以4位分组（如1101 0101）。  

下表展示0至15的十进制与二进制对应关系：  

| 十进制值 | 二进制值 |  
| --- | --- |  
| 0 | 0 |  
| 1 | 1 |  
| 2 | 10 |  
| 3 | 11 |  
| 4 | 100 |  
| 5 | 101 |  
| 6 | 110 |  
| 7 | 111 |  
| 8 | 1000 |  
| 9 | 1001 |  
| 10 | 1010 |  
| 11 | 1011 |  
| 12 | 1100 |  
| 13 | 1101 |  
| 14 | 1110 |  
| 15 | 1111 |  

**二进制转十进制**  
（以下示例均针对无符号整数）  

以8位二进制数0101 1110为例：  
其值为(0×128) + (1×64) + (0×32) + (1×16) + (1×8) + (1×4) + (1×2) + (0×1) = 64 + 16 + 8 + 4 + 2 = 94  

表格化转换过程：  
| 二进制位 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 0 |  
| --- | --- | --- | --- | --- | --- | --- | --- | --- |  
| ×位权值 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  
| = 总和(94) | 0 | 64 | 0 | 16 | 8 | 4 | 2 | 0 |  

转换1001 0111：  
| 二进制位 | 1 | 0 | 0 | 1 | 0 | 1 | 1 | 1 |  
| --- | --- | --- | --- | --- | --- | --- | --- | --- |  
| ×位权值 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  
| = 总和(151) | 128 | 0 | 0 | 16 | 0 | 4 | 2 | 1 |  
∴ 1001 0111二进制 = 151十进制  

此方法可扩展至16/32位二进制数，建议从右向左逐位计算，每次将位权值乘以2。  

**十进制转二进制方法1**  
持续除以2并记录余数，最后自底向上组合余数得二进制数。  

转换148：  
148 ÷ 2 = 74 余0  
74 ÷ 2 = 37 余0  
37 ÷ 2 = 18 余1  
18 ÷ 2 = 9 余0  
9 ÷ 2 = 4 余1  
4 ÷ 2 = 2 余0  
2 ÷ 2 = 1 余0  
1 ÷ 2 = 0 余1  
余数自底向上：1001 0100  
∴ 148十进制 = 1001 0100二进制  

验证：  
(1×128) + (0×64) + (0×32) + (1×16) + (0×8) + (1×4) + (0×2) + (0×1) = 148  

此方法适合人工计算但需存储中间结果。  

**十进制转二进制方法2**  
从最高位权开始正向计算。  

转换148：  
- 148 ≥ 128？是 → 128位=1，余148-128=20  
- 20 ≥ 64？否 → 64位=0  
- 20 ≥ 32？否 → 32位=0  
- 20 ≥ 16？是 → 16位=1，余20-16=4  
- 4 ≥ 8？否 → 8位=0  
- 4 ≥ 4？是 → 4位=1，余0  
- 剩余位为0  

表格化：  
| 二进制位 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |  
| --- | --- | --- | --- | --- | --- | --- | --- | --- |  
| ×位权值 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  
| = 总和(148) | 128 | 0 | 0 | 16 | 0 | 4 | 0 | 0 |  

此方法适合8位二进制数的人工计算。  

**十进制转二进制方法3**  
通过整数除法判断奇偶性。  

转换148：  
148 ÷ 128 = 1（奇）→ 位=1  
148 ÷ 64 = 2（偶）→ 位=0  
148 ÷ 32 = 4（偶）→ 位=0  
148 ÷ 16 = 9（奇）→ 位=1  
148 ÷ 8 = 18（偶）→ 位=0  
148 ÷ 4 = 37（奇）→ 位=1  
148 ÷ 2 = 74（偶）→ 位=0  
148 ÷ 1 = 148（偶）→ 位=0  
结果：1001 0100  

此方法无需条件判断但计算量大。  

**其他示例**  
转换117（方法1）：  
117÷2=58余1 → 58÷2=29余0 → 29÷2=14余1 → 14÷2=7余0 → 7÷2=3余1 → 3÷2=1余1 → 1÷2=0余1  
∴ 117 = 0111 0101二进制  

转换117（方法2）：  
117≥64→64位=1，余53  
53≥32→32位=1，余21  
21≥16→16位=1，余5  
5<8→8位=0  
5≥4→4位=1，余1  
1<2→2位=0  
1≥1→1位=1  
∴ 117 = 0111 0101二进制  

**二进制加法**  
以0110(6) + 0111(7)为例：  
```
  0110
+ 0111
------
  1101  (13)
```
计算过程：  
- 右起第1列：0+1=1  
- 第2列：1+1=0，进位1  
- 第3列：1+1+进位1=1，进位1  
- 第4列：0+0+进位1=1  

**有符号数与二进制补码（two's complement）**  
有符号整数采用**二进制补码**存储：  
- 最高位为符号位：0正/零，1负  
- 正数：同无符号表示  
- 负数：正数按位取反加1  

**十进制转二进制补码**  
转换-5：  
1. 5的二进制：0000 0101  
2. 按位取反：1111 1010  
3. 加1：1111 1011  

转换-76：  
1. 76的二进制：0100 1100  
2. 按位取反：1011 0011  
3. 加1：1011 0100  

**二进制补码转十进制**  
- 符号位为0：同无符号转换  
- 符号位为1：  
  1. 按位取反  
  2. 加1  
  3. 转十进制后添加负号  

转换1001 1110：  
1. 取反：0110 0001  
2. 加1：0110 0010  
3. 转十进制：64+32+2=98  
4. 添加负号：-98  

替代方法：符号位代表负权值  
1001 1110 = (1×-128) + (0×64) + (0×32) + (1×16) + (1×8) + (1×4) + (1×2) + (0×1) = -128+16+8+4+2 = -98  

**类型的重要性**  
二进制1011 0100的解释取决于变量类型：  
- 无符号整数 → 180  
- 有符号整数（补码）→ -76  
类型决定编码/解码方式（C++20起强制使用补码）。  

**浮点数转换**  
浮点数转换更复杂（非必需知识），详见[此网站](http://www.tfinley.net/notes/cps104/floating.html)。  

**测验**  
**问题1**  
转换0100 1101：  
| 二进制位 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |  
| --- | --- | --- | --- | --- | --- | --- | --- | --- |  
| ×位权值 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  
| = 总和(77) | 0 | 64 | 0 | 0 | 8 | 4 | 0 | 1 |  
答案：77  

**问题2**  
转换93（8位无符号）：  
方法1：93÷2=46余1 → 46÷2=23余0 → 23÷2=11余1 → 11÷2=5余1 → 5÷2=2余1 → 2÷2=1余0 → 1÷2=0余1 → 0101 1101  
方法2：93≥64→64位=1余29；29<32→32位=0；29≥16→16位=1余13；13≥8→8位=1余5；5≥4→4位=1余1；1<2→2位=0；1≥1→1位=1 → 0101 1101  

**问题3**  
转换-93（8位补码）：  
1. 93的二进制：0101 1101  
2. 取反：1010 0010  
3. 加1：1010 0011  

**问题4**  
转换1010 0010（无符号）：  
(0×1) + (1×2) + (0×4) + (0×8) + (0×16) + (1×32) + (0×64) + (1×128) = 2+32+128=162  

**问题5**  
转换1010 0010（补码）：  
1. 取反：0101 1101  
2. 加1：0101 1110  
3. 转十进制：64+16+8+4+2=94  
4. 添加负号：-94  

**问题6**  
打印0-255的8位二进制程序：  
```cpp
#include <iostream>

void printBit(int x, int pow)
{
    std::cout << ((x / pow) % 2);
}

void print8BitBinary(int x)
{
    printBit(x, 128);
    printBit(x, 64);
    printBit(x, 32);
    printBit(x, 16);
    std::cout << ' ';
    printBit(x, 8);
    printBit(x, 4);
    printBit(x, 2);
    printBit(x, 1);    
}

int main()
{
    std::cout << "输入一个0到255之间的整数: ";
    int x{};
    std::cin >> x;
    print8BitBinary(x);
    std::cout << '\n';
    return 0;
}
```

[下一课 7.1 复合语句（语句块）](Chapter-7/lesson7.1-compound-statements-blocks.md)  
[返回主页](/)  
[上一课 O.3 位运算符与位掩码](Chapter-O/lessonO.3-bit-manipulation-with-bitwise-operators-and-bit-masks.md)