O.2 — 位操作符
=======================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  

2025年2月26日（首次发布于2007年6月17日）  

位操作符概述  
----------------  

C++提供6个位操作符（bitwise operators）：  

| 操作符       | 符号 | 形式      | 功能描述                                |
|--------------|------|-----------|----------------------------------------|
| 左移         | <<   | x << n    | 将`x`的各位左移`n`位，空位补0           |
| 右移         | >>   | x >> n    | 将`x`的各位右移`n`位，空位补0           |
| 位取反       | ~    | ~x        | 逐位取反                               |
| 位与         | &    | x & y     | 当对应位均为1时结果为1                 |
| 位或         | \|   | x \| y    | 当对应位任意为1时结果为1               |
| 位异或       | ^    | x ^ y     | 当对应位不同时结果为1                  |  

这些操作符不会修改操作数本身。  

> **作者提示**  
> 以下示例多使用4位二进制值以便演示。实际程序中位数取决于对象大小（如2字节对象含16位）。  
>  
> 为提高可读性，代码示例外的二进制字面量可能省略`0b`前缀。  

位操作符适用于整型类型和`std::bitset`。示例中使用`std::bitset`便于二进制输出。  

> **最佳实践**  
> 为避免意外结果，请对无符号整型或`std::bitset`使用位操作符。  

位左移（<<）与位右移（>>）操作符  
----------------  

**位左移**操作符（<<）将二进制位向左移动。左操作数提供初始位序列，右操作数指定移动位数。例如`x << 2`表示"将x的位左移2位"。  

左移时右侧补0，溢出位永久丢失。以`0011`为例：  
```
0011 << 1 → 0110  
0011 << 2 → 1100  
0011 << 3 → 1000（丢失最左位）  
```  

**位右移**操作符（>>）同理但方向相反。以`1100`为例：  
```
1100 >> 1 → 0110  
1100 >> 2 → 0011  
1100 >> 3 → 0001（丢失最右位）  
```  

C++示例程序：  
```cpp
#include <bitset>
#include <iostream>

int main()
{
    std::bitset<4> x{ 0b1100 };
    std::cout << x << '\n';            // 1100
    std::cout << (x >> 1) << '\n';     // 0110（右移1位）
    std::cout << (x << 1) << '\n';     // 1000（左移1位）
    return 0;
}
```  

> **进阶阅读**  
> C++的位移操作与[字节序（endianness）](https://en.wikipedia.org/wiki/Endianness)无关：左移始终向最高有效位方向，右移向最低有效位方向。  

输入/输出操作符的重载  
----------------  

现代程序中位移操作符更常用于I/O操作：  
```cpp
unsigned int x{ 0b0100 };
x = x << 1;             // 使用<<进行位移
std::cout << x;         // 使用<<进行输出
```  

编译器通过操作数类型区分功能：左操作数为整型时执行位移，为输出流时执行输出。  

> **注意**  
> 同时使用位移和输出时需注意括号优先级：  
> ```cpp
> std::cout << x << 1;    // 输出x的值和数字1
> std::cout << (x << 1);  // 输出x左移后的值
> ```  

位取反操作符（~）  
----------------  

位取反操作符（~）将每个二进制位取反：  
```
~0011 → 1100  
~0000 0100 → 1111 1011  
```  

不同位宽的影响示例：  
```cpp
std::bitset<4> b4{0b0100};  // 0100（值4）
std::bitset<8> b8{0b0100};  // 00000100（值4）

b4 = ~b4;  // 1011（值11） 
b8 = ~b8;  // 11111011（值251）
```  

位或操作符（|）  
----------------  

位或操作符（|）在任意对应位为1时结果为1。计算`0b0101 | 0b0110`：  
```
0101  
0110  
----  
0111  
```  

复合位或示例：  
```cpp
std::cout << (0b0111 | 0b0011 | 0b0001);  // 输出0111
```  

位与操作符（&）  
----------------  

位与操作符（&）在对应位均为1时结果为1。计算`0b0101 & 0b0110`：  
```
0101  
0110  
----  
0100  
```  

复合位与示例：  
```cpp
std::cout << (0b0001 & 0b0011 & 0b0111);  // 输出0001
```  

位异或操作符（^）  
----------------  

位异或操作符（^）在对应位不同时结果为1。计算`0b0110 ^ 0b0011`：  
```
0110  
0011  
----  
0101  
```  

复合异或示例：  
```cpp
std::cout << (0b0001 ^ 0b0011 ^ 0b0111);  // 输出0101
```  

位操作赋值操作符  
----------------  

C++提供以下位操作赋值操作符：  

| 操作符       | 符号  | 形式      | 功能                    |
|--------------|-------|-----------|------------------------|
| 左移赋值     | <<=   | x <<= n   | 等价于x = x << n       |
| 右移赋值     | >>=   | x >>= n   | 等价于x = x >> n       |
| 位与赋值     | &=    | x &= y    | 等价于x = x & y        |
| 位或赋值     | \|=   | x \|= y   | 等价于x = x \| y       |
| 位异或赋值   | ^=    | x ^= y    | 等价于x = x ^ y        |  

示例：  
```cpp
std::bitset<4> bits{0b0100};
bits >>= 1;  // 0010
```  

> **注意**  
> 无位取反赋值操作符，需使用`x = ~x`实现。  

小整型位操作注意事项  
----------------  

对小于`int`的整型（如`char`）进行位操作时，会发生整型提升（integral promotion）：  

```cpp
std::uint8_t c{0b00001111};
std::cout << ~c;  // 可能错误输出32位取反结果
```  

解决方案：  
```cpp
std::cout << static_cast<std::uint8_t>(~c);  // 正确输出8位取反
```  

> **最佳实践**  
> 避免对小于`int`的整型进行位移操作。  

总结  
----------------  

位操作规则：  
- 位或（|）：列中任意1则结果为1  
- 位与（&）：列中全1则结果为1  
- 位异或（^）：列中1的数量为奇数则结果为1  

测验  
----------------  

**问题1**  
a) 0110 >> 2 → 0001  
b) 0011 | 0101 → 0111  
c) 0011 & 0101 → 0001  
d) (0011 | 0101) & 1001 → 0001  

**问题2**（循环左移实现）  
```cpp
std::bitset<4> rotl(std::bitset<4> bits) {
    bool leftbit = bits.test(3);
    bits <<= 1;
    if(leftbit) bits.set(0);
    return bits;
}
```  

**问题3**（无test/set版本）  
```cpp
std::bitset<4> rotl(std::bitset<4> bits) {
    return (bits << 1) | (bits >> 3);
}
```  

[下一课 O.3 — 位操作与位掩码](Chapter-O/lessonO.3-bit-manipulation-with-bitwise-operators-and-bit-masks.md)  
[返回主页](/)  
[上一课 O.1 — 使用std::bitset进行位操作](Chapter-O/lessonO.1-bit-flags-and-bit-manipulation-via-stdbitset.md)