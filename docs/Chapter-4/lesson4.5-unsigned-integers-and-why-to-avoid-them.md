4.5 — 无符号整数及其规避原因  
===============================================  

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  

2019年4月23日，下午12:04（太平洋夏令时）  
2024年8月29日  

无符号整数（Unsigned Integers）  
----------------  

前文课程（[4.4 — 有符号整数](Chapter-4/lesson4.4-signed-integers.md)）介绍了有符号整数（signed integers），这类类型可存储正负整数（含零）。  

C++同时支持**无符号整数（unsigned integers）**，此类整数仅能存储非负整数。  

定义无符号整数  
----------------  

定义无符号整数需使用 *unsigned* 关键字（keyword）。约定俗成置于类型前：  

```cpp
unsigned short us;
unsigned int ui;
unsigned long ul;
unsigned long long ull;
```  

无符号整数范围  
----------------  

1字节无符号整数范围为0至255。对比1字节有符号整数范围-128至127：两者均可存储256个不同值，但有符号整数将半数范围用于负数，而无符号整数能存储两倍大小的正数。  

无符号整数范围表：  

| 大小/类型 | 范围 |
| --- | --- |
| 8位无符号 | 0 至 255 |
| 16位无符号 | 0 至 65,535 |
| 32位无符号 | 0 至 4,294,967,295 |
| 64位无符号 | 0 至 18,446,744,073,709,551,615 |  

n位无符号变量的范围为0至(2<sup>n</sup>)-1。  

当无需负数时，无符号整数特别适用于网络通信和内存受限系统，因其可在不占用额外内存的前提下存储更多正数。  

术语记忆技巧  
----------------  

新手易混淆有符号（signed）和无符号（unsigned）。可通过以下方式区分：为区别正负数，我们使用负号。若未提供符号，则默认数字为正。因此，带符号整数（signed integer）可区分正负，而无符号整数（unsigned integer）默认所有值为正数。  

无符号整数溢出（Unsigned Integer Overflow）  
----------------  

若尝试将数字`280`（需9位表示）存入1字节（8位）无符号整数会发生什么？答案是溢出（overflow）。  

> **作者注**  
> 奇怪的是，C++标准明确声明"涉及无符号操作数的计算永不溢出"。这与编程界共识——整数溢出包含有符号和无符号情况——相悖（[引用](https://en.wikipedia.org/wiki/Integer_overflow#Definition_variations_and_ambiguity)）。鉴于多数程序员视其为溢出，我们将沿用此说法。  

若超出无符号类型范围，该值会被（类型最大值+1）整除并保留余数。  

`280`超出1字节范围（0-255）。类型最大值+1为256。因此280÷256得商1余24，实际存储余数24。  

另一种理解方式：超出类型表示范围的数字会"环绕"（wrap around，亦称"模环绕"）。`255`在1字节范围内，故正常存储。`256`超出范围则环绕至`0`，`257`环绕至`1`，`280`环绕至`24`。  

通过2字节短整型（short）观察此现象：  

```cpp
#include <iostream>

int main()
{
    unsigned short x{ 65535 }; // 16位无符号最大值
    std::cout << "x原值: " << x << '\n';

    x = 65536; // 超出范围，触发模环绕
    std::cout << "x当前值: " << x << '\n';

    x = 65537; // 超出范围，触发模环绕
    std::cout << "x当前值: " << x << '\n';

    return 0;
}
```  

此程序输出结果如何？  

> （注意：编译时编译器会发出溢出或截断警告——需禁用"视警告为错误"才能运行）  

```plaintext
x原值: 65535
x当前值: 0
x当前值: 1
```  

反向环绕同样可能发生。0在2字节无符号整数中可表示，故无异常。-1不可表示，将环绕至范围上限值65535。-2环绕至65534，依此类推。  

```cpp
#include <iostream>

int main()
{
    unsigned short x{ 0 }; // 最小2字节无符号值
    std::cout << "x原值: " << x << '\n';

    x = -1; // 超出范围，触发模环绕
    std::cout << "x当前值: " << x << '\n';

    x = -2; // 超出范围，触发模环绕
    std::cout << "x当前值: " << x << '\n';

    return 0;
}
```  

```plaintext
x原值: 0
x当前值: 65535
x当前值: 65534
```  

> （某些编译器会触发警告，因其检测到整数字面量超出范围。若需编译，请临时禁用"视警告为错误"）  

> **扩展阅读**  
> 电子游戏史上多起著名bug源于无符号整数环绕行为。街机游戏《大金刚》因溢出bug无法通过22关——该错误导致玩家奖励时间不足。  
>  
> PC游戏《文明》中，甘地常率先使用核武器，与其被动性格相悖。玩家推测其初始攻击性设为1，但选择民主政体会获得-2攻击修正（使当前攻击值降为-1），导致攻击性溢出至255成为极端好战！但近期席德·梅尔（作者）澄清事实并非如此。  

无符号整数争议  
----------------  

许多开发者（及谷歌等大型开发商）认为应避免使用无符号整数，主要因其易引发两类问题：  

1. **下界溢出风险**：有符号值的范围上下限远离0，意外溢出较难发生。无符号整数范围下限为0（接近常用数值区），更易触发下界溢出。  
   例：两无符号数相减（2减3）：  
   ```cpp
   #include <iostream>
   // 假设int为4字节
   int main()
   {
       unsigned int x{ 2 };
       unsigned int y{ 3 };
       std::cout << x - y << '\n'; // 输出4294967295（错误！）
       return 0;
   }
   ```  
   预期结果`-1`无法用无符号整数表示，导致溢出输出：  
   ```plaintext
   4294967295
   ```  
   另一常见问题是递减至负数时的意外环绕（将在循环课程详述）。  

2. **符号混合陷阱**：C++中混合有符号和无符号整数运算时，有符号整数通常被隐式转换为无符号整数，结果亦为无符号。  
   例：  
   ```cpp
   #include <iostream>
   // 假设int为4字节
   int main()
   {
       unsigned int u{ 2 };
       signed int s{ 3 };
       std::cout << u - s << '\n'; // 2 - 3 = 4294967295
       return 0;
   }
   ```  
   输出同为：  
   ```plaintext
   4294967295
   ```  
   若`u`为有符号则结果正确，但因其为无符号（易被忽略），`s`被转换为无符号，结果`-1`被视为无符号值导致溢出。  

   另一危险案例：  
   ```cpp
   #include <iostream>
   // 假设int为4字节
   int main()
   {
       signed int s { -1 };
       unsigned int u { 1 };
       if (s < u) // -1隐式转换为4294967295，4294967295 < 1为假
           std::cout << "-1小于1\n";
       else
           std::cout << "1小于-1\n"; // 此语句执行
       return 0;
   }
   ```  
   输出：  
   ```plaintext
   1小于-1
   ```  
   程序虽编译通过且逻辑看似合理，却输出错误结果。尽管编译器应警告符号不匹配，但某些合法操作（如两正数比较）也会触发相同警告，导致问题难以排查。  

> **相关内容**  
> 二元操作数类型转换规则见课程[10.5 — 算术转换](Chapter-10/lesson10.5-arithmetic-conversions.md)  
> if语句详见[4.10 — if语句简介](Chapter-4/lesson4.10-introduction-to-if-statements.md)  

更难检测的问题案例：  
```cpp
#include <iostream>
// 假设int为4字节
void doSomething(unsigned int x)
{
    // 运行x次代码
    std::cout << "x值为 " << x << '\n';
}

int main()
{
    doSomething(-1); // 错误传递负值
    return 0;
}
```  
函数设计者预期调用时传入正数，但调用者错误传入`-1`。此时有符号参数`-1`隐式转换为无符号形参，`-1`超出无符号范围，环绕至4294967295，导致程序行为异常。  

更严峻的是，此类问题难以预防。除非编译器严格检查符号转换警告（建议开启），否则通常不会提示此错误。  

综上，无符号整数易引发常见问题、导致不可预期行为且难以排查。因此我们提出略有争议的最佳实践：除特定情况外，避免使用无符号类型。  

> **最佳实践（Best Practice）**  
> 存储数值（即使应为非负值）和数学运算时，优先选用有符号数。避免混合有符号和无符号数。  

> **延伸阅读**  
> 支持上述建议的补充材料（含常见反对论点反驳）：  
> 1. [C++专题讨论](https://www.youtube.com/watch?v=_nrly6PH6NU)（参见9:48-13:08, 41:06-45:26, 1:02:50-1:03:15）  
> 2. [下标和大小应为有符号](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1428r0.pdf)（C++之父比雅尼·斯特劳斯特鲁普）  
> 3. [Libtorrent博客：无符号整数](https://blog.libtorrent.org/2016/05/unsigned-integers/)  

无符号整数适用场景  
----------------  

仍有少数情况适用/必须使用无符号整数：  

1. **位操作**：处理位操作（见章节O）时首选无符号整数。某些算法（如加密和随机数生成）需明确定义的环绕行为时亦适用。  
2. **数组索引**：数组索引相关操作仍不可避免使用无符号数，数组课程将深入讨论。  
3. **嵌入式系统**：开发Arduino等嵌入式系统或处理器/内存受限环境时，出于性能考量更常接受（或不可避免）使用无符号数。  

[下一课 4.6 固定宽度整数与size_t](Chapter-4/lesson4.6-fixed-width-integers-and-size-t.md)  
[返回主页](/)  
[上一课 4.4 有符号整数](Chapter-4/lesson4.4-signed-integers.md)