4.8 — 浮点数  
=============================

[*作者：Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2024年11月24日（首次发布于2007年6月9日）  

整数适用于计算整数值，但有时我们需要存储极大（正/负）数值或含小数部分的数值。**浮点型（floating point）**变量可存储带小数部分的数值，如4320.0、-3.33或0.01226。名称中的"浮点"指小数点可"浮动"—即支持小数点前后不同位数的数字组合。浮点数据类型始终带符号（可存储正值和负值）。  

> **编程提示**  
> 代码中书写浮点数时，小数分隔符必须使用小数点。若您所在国家使用逗号作为小数分隔符，需适应使用小数点。  

C++浮点类型  
----------------  

C++有三种基本浮点数据类型：单精度`float`、双精度`double`和扩展精度`long double`。与整数类似，C++未明确定义这些类型的具体大小。  

| 类别        | C++类型      | 典型大小      |  
|-------------|-------------|--------------|  
| 浮点型      | float       | 4字节        |  
| 双精度型    | double      | 8字节        |  
| 扩展双精度型| long double | 8、12或16字节|  

现代架构中，浮点类型通常采用IEEE 754标准定义的格式实现（参见<https://en.wikipedia.org/wiki/IEEE_754>）。因此，`float`几乎总为4字节，`double`几乎总为8字节。而`long double`较为特殊：不同平台其大小在8至16字节间变化，可能不遵循IEEE 754标准。建议避免使用`long double`。  

> **教程说明**  
> 本系列教程假定您的编译器对`float`和`double`使用IEEE 754兼容格式。可通过以下代码验证：  
> ```cpp  
> #include <iostream>  
> #include <limits>  
>  
> int main()  
> {  
>     std::cout << std::boolalpha;  
>     std::cout << "float: " << std::numeric_limits<float>::is_iec559 << '\n';  
>     std::cout << "double: " << std::numeric_limits<double>::is_iec559 << '\n';  
>     std::cout << "long double: " << std::numeric_limits<long double>::is_iec559 << '\n';  
> }  
> ```  

> **进阶阅读**  
> `float`通常采用4字节IEEE 754单精度格式实现  
> `double`通常采用8字节IEEE 754双精度格式实现  
> `long double`的常见实现方式包括：  
> * 8字节IEEE 754双精度格式（同double）  
> * 80位（常填充至12/16字节）x87扩展精度格式  
> * 16字节IEEE 754四倍精度格式  
> * 16字节双-双格式（非IEEE 754兼容）  

浮点变量与字面量  
----------------  

浮点变量定义示例：  
```cpp  
float f;  
double d;  
long double ld;  
```  

使用浮点字面量时，必须至少包含一个十进制位（即使小数为0）。这有助于编译器区分浮点数与整数：  
```cpp  
int a { 5 };      // 5表示整数  
double b { 5.0 }; // 5.0是浮点字面量（默认double类型）  
float c { 5.0f }; // 5.0f表示float类型  

int d { 0 };      // 0是整数  
double e { 0.0 }; // 0.0是双精度数  
```  

> **最佳实践**  
> 确保字面量类型与赋值变量类型匹配，避免不必要的精度损失转换。  

输出浮点数  
----------------  

考虑以下程序：  
```cpp  
#include <iostream>  

int main()  
{  
    std::cout << 5.0 << '\n';  
    std::cout << 6.7f << '\n';  
    std::cout << 9876543.21 << '\n';  
}  
```  
输出结果可能令人意外：  
```  
5  
6.7  
9.87654e+06  
```  

* 首行输出`5`而非`5.0`，因默认不显示小数部分为0的尾数  
* 第三行使用科学计数法表示  

浮点数范围  
----------------  

| 格式                     | 范围                           | 有效数字位数 |  
|--------------------------|--------------------------------|-------------|  
| IEEE 754单精度（4字节）  | ±1.18e-38 至 ±3.4e38          | 6-9（通常7）|  
| IEEE 754双精度（8字节）  | ±2.23e-308 至 ±1.8e308        | 15-18（通常16）|  
| x87扩展精度（80位）      | ±3.36e-4932 至 ±1.18e4932     | 18-21       |  
| IEEE 754四倍精度（16字节）| ±3.36e-4932 至 ±1.18e4932     | 33-36       |  

> **历史背景**  
> 80位x87扩展精度类型在现代处理器中常被填充至12/16字节。其范围与16字节类型相同（因指数位数相同），但后者可存储更多有效数字。  

浮点精度  
----------------  

考虑分数1/3的无限循环小数0.333...。计算机有限内存只能存储有限有效数字，导致精度损失。**精度（precision）**指浮点类型可精确表示的有效数字位数。  

* `float`：6-9位有效数字  
* `double`：15-18位（通常16位）  
* `long double`：根据字节数15/18/33位  

> **关键洞察**  
> 浮点类型仅能精确表示有限有效数字。超出精度的数字可能存储不精确。  

输出精度控制  
----------------  

`std::cout`默认显示6位有效数字。使用`std::setprecision()`输出操纵器可调整精度（需包含<iomanip>头文件）：  
```cpp  
#include <iomanip>  
#include <iostream>  

int main()  
{  
    std::cout << std::setprecision(17);  
    std::cout << 3.3333333333333333333f << '\n'; // float  
    std::cout << 3.3333333333333333333 << '\n';  // double  
}  
```  
输出：  
```  
3.3333332538604736  // float误差更大  
3.3333333333333335  // double更精确  
```  

> **操纵器特性**  
> 输出操纵器具有粘滞性（`std::setw`例外，需每次使用）。  

精度问题示例：  
```cpp  
#include <iomanip>  
#include <iostream>  

int main()  
{  
    float f { 123456789.0f }; // 10位有效数字  
    std::cout << std::setprecision(9) << f << '\n';  
}  
```  
输出：  
```  
123456792  // 精度损失导致舍入误差  
```  

> **最佳实践**  
> 优先选用`double`，除非对存储空间有严格限制。  

浮点比较陷阱  
----------------  

十进制0.1在二进制中为无限循环小数（0.000110011...），导致存储不精确：  
```cpp  
#include <iomanip>  
#include <iostream>  

int main()  
{  
    double d{0.1};  
    std::cout << d << '\n';               // 输出0.1  
    std::cout << std::setprecision(17);  
    std::cout << d << '\n';               // 显示实际存储值  
}  
```  
输出：  
```  
0.1  
0.10000000000000001  
```  

累计运算误差示例：  
```cpp  
double d2 = 0.1相加10次;  
// 预期1.0，实际输出0.99999999999999989  
```  

> **关键洞察**  
> 舍入误差（rounding error）是常态而非例外。避免使用浮点数处理金融数据。  

特殊值  
----------------  

IEEE 754支持：  
* **Inf**：有符号无穷大（+Inf/-Inf）  
* **NaN**：非数字  
* 有符号零（+0.0/-0.0）  

示例程序：  
```cpp  
#include <iostream>  

int main()  
{  
    double zero {0.0};  
    std::cout << 5.0/zero << '\n';  // +Inf  
    std::cout << -5.0/zero << '\n'; // -Inf  
    std::cout << 0.0/posinf << '\n';// +0  
    std::cout << -0.0/posinf << '\n';//-0  
    std::cout << zero/zero << '\n'; // NaN  
}  
```  

> **最佳实践**  
> 避免除以0.0，即使编译器支持。  

总结  
----------------  

浮点数要点：  
1. 适合存储极大/极小数值（含小数）  
2. 普遍存在微小舍入误差，运算会放大误差  

[下一课4.9 — 布尔值](Chapter-4/lesson4.9-boolean-values.md)  
[返回主页](/)  
[上一课4.7 — 科学记数法简介](Chapter-4/lesson4.7-introduction-to-scientific-notation.md)  