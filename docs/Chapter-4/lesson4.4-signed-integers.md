4.4 — 有符号整数（Signed integers）
================================================

[*作者：Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2024年12月28日（首次发布于2007年6月9日）  

**整数（integer）**是一种可以表示正负整数（含0）的整型数据类型（例如-2、-1、0、1、2）。C++提供*4*种主要的基本整数类型：

| 类型              | 最小尺寸 | 备注                        |
|-------------------|----------|-----------------------------|
| short int         | 16位     |                             |
| int               | 16位     | 现代架构通常为32位          |
| long int          | 32位     |                             |
| long long int     | 64位     |                             |

关键提示  
----------------  
不同整数类型的主要区别在于尺寸（size）——更大的整数类型可以存储更大的数值。

重要提醒  
C++仅保证整数类型的最小尺寸，而非具体尺寸。有关如何确定各类型在您机器上的实际尺寸，请参考课程[4.3 — 对象尺寸与sizeof运算符](Chapter-4/lesson4.3-object-sizes-and-the-sizeof-operator.md)。

技术说明  
严格来说，`bool`和`char`类型属于整型（integral types）（因为这些类型以整数值存储数据）。但在后续课程中，我们将暂时排除这两种类型的讨论。

有符号整数（Signed integers）  
----------------  
日常书写负数时，我们使用负号（-）。例如*-3*表示"负三"。我们通常也认可*+3*表示"正三"（尽管惯例上通常省略正号前缀）。

数值的正、负或零属性称为**符号（sign）**。  
默认情况下，C++的整数是**有符号的（signed）**，即数值的符号作为值的一部分存储。因此，有符号整数可以存储正数、负数和零。

本课重点讨论有符号整数，下节课将探讨无符号整数（unsigned integers）（只能存储非负数）。

定义有符号整数  
以下是定义四类有符号整数的推荐方式：
```cpp
short s;      // 推荐使用"short"而非"short int"
int i;
long l;       // 推荐使用"long"而非"long int"
long long ll; // 推荐使用"long long"而非"long long int"
```

虽然*short int*、*long int*或*long long int*同样有效，但我们推荐使用无*int*后缀的简写形式。添加*int*后缀不仅增加输入量，还会使类型名更难以与普通*int*变量区分，容易导致误读错误。

整数类型也可以添加可选的*signed*关键字，通常置于类型名前：
```cpp
signed short ss;
signed int si;
signed long sl;
signed long long sll;
```

但应避免使用此关键字，因为整数默认即有符号，该关键字是冗余的。

最佳实践  
推荐使用无*int*后缀和无*signed*前缀的简写类型。

有符号整数范围（Signed integer ranges）  
如前一课所述，具有n位的变量可以存储2^n个可能值。但具体是哪些值？我们称数据类型能存储的特定值集合为**范围（range）**。整数变量的范围由两个因素决定：尺寸（以位计）以及是否带符号。

例如，8位有符号整数的范围是-128至127。这意味着8位有符号整数可以安全存储-128到127之间的任何整数值。

以下是不同尺寸有符号整数的范围表：

| 尺寸/类型        | 范围                                      |
|------------------|------------------------------------------|
| 8位有符号        | -128 至 127                             |
| 16位有符号       | -32,768 至 32,767                       |
| 32位有符号       | -2,147,483,648 至 2,147,483,647         |
| 64位有符号       | -9,223,372,036,854,775,808 至 9,223,372,036,854,775,807 |

数学表达：n位有符号变量的范围是-(2^(n-1))至(2^(n-1)-1)。  
非数学理解：直接参考上表即可。

高级阅读  
上述范围基于"二进制补码（two’s complement）"表示法。该表示法是现代架构的行业标准（因其硬件实现更简单），现已被C++20标准强制要求。我们将在课程[O.4 — 整数的二进制与十进制转换](Chapter-O/lessonO.4-converting-integers-between-binary-and-decimal-representation.md)中讨论二进制补码。

在早期标准中，为历史兼容性允许使用"符号数值（sign-magnitude）"和"反码（ones complement）"表示法。这些表示法产生的范围是-(2^(n-1)-1)至+(2^(n-1)-1)。

溢出（Overflow）  
----------------  
若尝试将140赋值给8位有符号整数会发生什么？这个数值超出了8位有符号整数的存储范围。数值140需要9位表示（8位数值位+1位符号位），但8位有符号整数仅有8位可用（7位数值位+1位符号位）。

C++20标准明确指出："如果表达式求值过程中结果在数学上未定义或超出其类型可表示范围，则行为未定义（undefined）"。这通常称为**溢出（overflow）**。

因此，将140赋值给8位有符号整数将导致未定义行为。  
当算术运算（如加法或乘法）尝试生成超出可表示范围的值时，称为**整数溢出（integer overflow）**或**算术溢出（arithmetic overflow）**。对有符号整数而言，整数溢出将导致未定义行为。

```cpp
#include <iostream>

int main()
{
    // 假设是4字节整数
    int x { 2'147'483'647 }; // 4字节有符号整数的最大值
    std::cout << x << '\n';

    x = x + 1; // 整数溢出，未定义行为
    std::cout << x << '\n';

    return 0;
}
```

在作者机器上输出：
```
2147483647
-2147483648
```

但请注意，第二个输出是未定义行为的结果，实际输出可能因机器而异。

高级阅读  
无符号整数溢出的处理方式将在课程[4.5 — 无符号整数及其避免原因](Chapter-4/lesson4.5-unsigned-integers-and-why-to-avoid-them.md)中讨论。

总体而言，溢出会导致信息丢失，这几乎总是不可取的。若预期变量可能需要存储超出其范围的值，请使用更大范围的类型！

整数除法（Integer division）  
----------------  
当两个整数相除时，若商为整数，C++的表现符合预期：
```cpp
#include <iostream>

int main()
{
    std::cout << 20 / 4 << '\n';
    return 0;
}
```
输出预期结果：
```
5
```

但当整数除法产生小数结果时：
```cpp
#include <iostream>

int main()
{
    std::cout << 8 / 5 << '\n';
    return 0;
}
```
输出可能出乎意料：
```
1
```

当进行两个整数间的除法（称为**整数除法（integer division）**）时，C++总是生成整数结果。由于整数无法存储小数部分，任何小数部分都会被直接截断（而非四舍五入）。

仔细分析上例，8/5的结果是1.6。小数部分（0.6）被截断，结果保留1。也可以说8/5等于1余3，余数被丢弃，保留1。同理，-8/5的结果是-1。

警告  
使用整数除法时需格外小心，因为会丢失商的所有小数部分。但如果这正是您需要的，整数除法是安全且结果可预测的。

如需小数结果，我们将在课程[6.2 — 算术运算符](Chapter-6/lesson6.2-arithmetic-operators.md)中介绍相关方法。

测验时间  
----------------  
**问题1**  
5位有符号整数的范围是多少？  
  
<details><summary>答案</summary>5位数值可支持2^5=32个唯一值。对于有符号整数，这些值在正负数间几乎均分，负数额外多一个值。因此范围为-16至15。</details>  

**问题2a**  
13 / 5的结果是多少？  
  
<details><summary>答案</summary>13 / 5 = 2余3。余数被截断，结果为2。</details>  

**问题2b**  
-13 / 5的结果是多少？  
  
<details><summary>答案</summary>-13 / 5 = -2余-3。余数被截断，结果为-2。</details>  

[下一课 4.5 无符号整数及其避免原因](Chapter-4/lesson4.5-unsigned-integers-and-why-to-avoid-them.md)  
[返回主页](/)  
[上一课 4.3 对象尺寸与sizeof运算符](Chapter-4/lesson4.3-object-sizes-and-the-sizeof-operator.md)