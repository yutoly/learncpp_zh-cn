4.6 — 固定宽度整数与 size_t  
========================================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2011年11月25日 下午9:59（太平洋标准时间）  
2025年1月21日  

在前几节关于整数的课程中，我们提到C++仅保证整数类型的最小尺寸——实际大小可能因目标系统而异。例如，`int`类型的最小尺寸是16位，但在现代架构中通常为32位。若因普遍情况假设`int`为32位，当实际为16位时程序将出现异常（例如存储超出16位范围的值会导致溢出或未定义行为）。例如：  
```
#include <iostream>

int main()
{
    int x { 32767 };        // x 可能是16位或32位
    x = x + 1;              // 若int是16位，32768会溢出；32位则正常
    std::cout << x << '\n'; // 输出结果取决于架构

    return 0;
}
```  
在32位`int`系统中，`32768`可正常存储，程序输出`32768`。但在16位`int`系统中（范围-32,768至32,767），`x = x + 1`会导致溢出，存储`-32768`并输出。  

若为确保跨平台兼容性而假设`int`仅16位，将严重限制可用范围。而在实际32位系统中，每个`int`浪费50%内存。  

**关键洞察**  
多数情况下，函数内临时使用的少量`int`变量不会造成内存问题（范围限制才是主要问题）。但当程序分配数百万个`int`时，每个变量浪费2字节将显著影响总内存使用。  

为何不固定整数类型尺寸？  
简而言之，这源于C语言早期设计理念：当时计算机性能低下，C选择保持整数类型尺寸开放，让编译器根据目标架构选择最优尺寸。开发者只需使用`int`而无需担心性能优化。  

现代视角下，这种不统一的整数范围设计（尤其在强调可移植性的语言中）存在缺陷。  

固定宽度整数  
为解决上述问题，C++11提供保证跨平台尺寸统一的**固定宽度整数（fixed-width integers）**，定义于\<cstdint\>头文件：  

| 类型名称           | 固定尺寸 | 固定范围                                  | 备注                                                                 |
|-------------------|---------|------------------------------------------|---------------------------------------------------------------------|
| std::int8_t       | 1字节   | -128至127                                | 多数系统视为signed char，详见下文警告                                |
| std::uint8_t      | 1字节   | 0至255                                   | 多数系统视为unsigned char，详见下文警告                              |
| std::int16_t      | 2字节   | -32,768至32,767                          |                                                                     |
| std::uint16_t     | 2字节   | 0至65,535                                |                                                                     |
| std::int32_t      | 4字节   | -2,147,483,648至2,147,483,647            |                                                                     |
| std::uint32_t     | 4字节   | 0至4,294,967,295                         |                                                                     |
| std::int64_t      | 8字节   | -9,223,372,036,854,775,808至9,223,372,036,854,775,807 |                                                                     |
| std::uint64_t     | 8字节   | 0至18,446,744,073,709,551,615            |                                                                     |  

示例：  
```
#include <cstdint> // 引入固定宽度整数
#include <iostream>

int main()
{
    std::int32_t x { 32767 }; // x 始终是32位整数
    x = x + 1;                // 32768始终在范围内
    std::cout << x << '\n';

    return 0;
}
```  
**最佳实践**  
当需要确保整数范围时，使用固定宽度整数类型。  

**警告：`std::int8_t`与`std::uint8_t`通常表现类似字符类型**  
由于C++标准缺陷，现代编译器通常将8位固定宽度类型视为`signed char`和`unsigned char`。例如：  
```
#include <cstdint>
#include <iostream>

int main()
{
    std::int8_t x { 65 };   // 用值65初始化8位整数
    std::cout << x << '\n'; // 预期输出65，但实际可能不同

    return 0;
}
```  
该程序可能不会输出`65`，具体原因将在[4.12 — 类型转换与static_cast](Chapter-4/lesson4.12-introduction-to-type-conversion-and-static_cast.md)中讲解。  

**进阶说明**  
固定宽度整数并非新类型，而是现有整数类型的别名。例如在32位`int`系统中，`std::int32_t`是`int`的别名；在16位`int`系统中可能是`long`的别名。  

8位类型的特殊情况：  
由于`signed char`通常是唯一的8位有符号类型，`std::int8_t`常作为其别名。罕见情况下，若平台有专有8位类型，可能使用该类型别名。`std::uint8_t`同理。  

其他固定宽度类型的缺点  
1. 非全平台支持：仅存在于支持对应二进制表示的架构  
2. 可能性能劣于更宽类型：例如32位类型在64位CPU可能更慢（但内存限制常更关键）  

快速与最小整数类型（可选）  
为平衡性能与内存，C++定义两类补充类型：  
- **快速类型**（std::int_fast#_t / std::uint_fast#_t）：至少#位的最快类型  
- **最小类型**（std::int_least#_t / std::uint_least#_t）：至少#位的最小类型  

示例（作者Visual Studio结果）：  
```
least 8:  8 bits
least 16: 16 bits
least 32: 32 bits

fast 8:  8 bits
fast 16: 32 bits
fast 32: 32 bits
```  
`std::int_fast16_t`选择32位类型以获得更快处理速度。  

**缺点**：  
- 使用率低导致易错  
- 快速类型可能浪费内存  
- 不同架构表现不同（违背固定宽度初衷）  

**最佳实践**  
因可能导致跨平台行为差异，建议避免使用快速/最小类型。  

整数类型最佳实践  
综合考量后建议：  
* 通用情况使用`int`（当范围无严格要求时）  
* 需保证范围时使用`std::int#_t`  
* 位操作或需明确回绕行为时使用`std::uint#_t`  

应避免：  
* `short`/`long`（改用固定宽度）  
* 快速/最小类型  
* 无符号类型存储数量值  
* 8位固定宽度类型（易混淆为字符）  
* 编译器专用类型（如Visual Studio的__int8）  

std::size_t 解析  
`sizeof`运算符返回`std::size_t`类型值。**std::size_t**是实现定义的无符号整数类型别名，用于表示对象字节大小或长度。  

**最佳实践**  
显式使用`std::size_t`时应包含\<cstddef\>头文件：  
```
#include <cstddef>
#include <iostream>

int main()
{
    int x { 5 };
    std::size_t s { sizeof(x) }; // sizeof返回std::size_t
    std::cout << s << '\n';      // 输出4（32位系统）

    return 0;
}
```  
`std::size_t`尺寸与应用程序地址宽度相关（32位应用通常32位，64位应用64位）。  

对象尺寸上限（可选）  
`sizeof`返回值类型决定了对象尺寸上限。C++20规定：若对象字节数超过`std::size_t`最大值，则程序非法。例如在4字节`std::size_t`系统中，最大允许对象尺寸为4,294,967,295字节。  

实际限制可能更低（如编译器限制为最大值一半）。现代64位系统中，此限制通常不成问题。  

[下一课 4.7 科学记数法简介](Chapter-4/lesson4.7-introduction-to-scientific-notation.md)  
[返回主页](/)  
[上一课 4.5 无符号整数及其避免原因](Chapter-4/lesson4.5-unsigned-integers-and-why-to-avoid-them.md)