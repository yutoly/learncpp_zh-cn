17.12 — 多维C风格数组
=========================================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看Alex的所有文章")
2007年7月6日，下午4:50（太平洋夏令时）
2023年11月24日更新

考虑类似[井字棋](https://en.wikipedia.org/wiki/Tic-tac-toe)的游戏。标准棋盘是3×3网格，玩家轮流放置'X'和'O'符号，首先连成三子者获胜。虽然可将棋盘数据存储为9个独立变量，但当存在多个相同元素实例时，使用数组更优：
```
int ttt[9]; // C风格整型数组（值0=空，1=玩家1，2=玩家2）
```
这定义了一个C风格数组，其9个元素在内存中顺序排列。我们可将这些元素想象为单行数值：
```
// ttt[0] ttt[1] ttt[2] ttt[3] ttt[4] ttt[5] ttt[6] ttt[7] ttt[8]
```
数组的**维度（dimension）**指选择元素所需的索引数量。仅包含单个维度的数组称为**单维数组（single-dimensional array）**或**一维数组（one-dimensional array）**（有时缩写为**1d数组**）。上例`ttt`即一维数组，因元素可通过单索引访问（如`ttt[2]`）。

但注意一维数组与二维的井字棋棋盘并不相似。我们可以改进。

### 二维数组
先前课程提到，数组元素可为任意对象类型。这意味着数组元素类型可以是另一个数组！定义此类数组很简单：
```
int a[3][5]; // 由3个元素组成的数组，每个元素是包含5个整数的数组
```
数组的数组称为**二维数组（two-dimensional array）**（有时缩写为**2d数组**），因其有两个下标。

使用二维数组时，通常将首个（左侧）下标视为选择行，第二个（右侧）下标视为选择列。概念上可将其布局想象为：
```
// 列0     列1     列2     列3     列4
// a[0][0] a[0][1] a[0][2] a[0][3] a[0][4]  行0
// a[1][0] a[1][1] a[1][2] a[1][3] a[1][4]  行1
// a[2][0] a[2][1] a[2][2] a[2][3] a[2][4]  行2
```
访问二维数组元素只需使用两个下标：
```
a[2][3] = 7; // a[行][列]，行=2，列=3
```
因此对于井字棋棋盘，可定义如下二维数组：
```
int ttt[3][3];
```
现在我们有了3×3网格的元素，可通过行列索引轻松操作！

### 多维数组
超过一维的数组称为**多维数组（multidimensional arrays）**。

C++甚至支持超过二维的多维数组：
```
int threedee[4][4][4]; // 4x4x4数组（由4个数组组成的数组，每个数组包含4个含4个整数的数组）
```
例如，《我的世界》中地形被划分为16x16x16区块（称为区块段）。支持超过三维的数组，但较为罕见。

### 二维数组的内存布局
内存是线性（一维）的，因此多维数组实际以元素序列形式存储。以下数组在内存中有两种存储方式：
```
// 列0    列1    列2    列3    列4
// [0][0] [0][1] [0][2] [0][3] [0][4]  行0
// [1][0] [1][1] [1][2] [1][3] [1][4]  行1
// [2][0] [2][1] [2][2] [2][3] [2][4]  行2
```
C++采用**行优先顺序（row-major order）**，元素在内存中按行逐行顺序放置（从左到右，从上到下）：
```
[0][0] [0][1] [0][2] [0][3] [0][4] [1][0] [1][1] [1][2] [1][3] [1][4] [2][0] [2][1] [2][2] [2][3] [2][4]
```
其他语言（如Fortran）使用**列优先顺序（column-major order）**，元素按列逐列顺序放置（从上到下，从左到右）：
```
[0][0] [1][0] [2][0] [0][1] [1][1] [2][1] [0][2] [1][2] [2][2] [0][3] [1][3] [2][3] [0][4] [1][4] [2][4]
```
在C++中，数组初始化时元素按行优先顺序初始化。遍历数组时，按内存布局顺序访问元素效率最高。

### 初始化二维数组
初始化二维数组时，使用嵌套花括号最简便，每组数字代表一行：
```
int array[3][5]
{
  { 1, 2, 3, 4, 5 },     // 行0
  { 6, 7, 8, 9, 10 },    // 行1
  { 11, 12, 13, 14, 15 } // 行2
};
```
部分编译器允许省略内层花括号，但为可读性强烈建议保留。

使用内层花括号时，缺失的初始化器将进行值初始化：
```
int array[3][5]
{
  { 1, 2 },          // 行0 = 1, 2, 0, 0, 0
  { 6, 7, 8 },       // 行1 = 6, 7, 8, 0, 0
  { 11, 12, 13, 14 } // 行2 = 11, 12, 13, 14, 0
};
```
初始化的多维数组可省略（仅）最左侧长度说明：
```
int array[][5]
{
  { 1, 2, 3, 4, 5 },
  { 6, 7, 8, 9, 10 },
  { 11, 12, 13, 14, 15 }
};
```
此时编译器可通过初始化器数量自动推导最左侧长度。不允许省略非最左侧维度：
```
int array[][] // 错误：缺失非最左侧维度
{
  { 1, 2, 3, 4 },
  { 5, 6, 7, 8 }
};
```
与普通数组类似，多维数组仍可初始化为0：
```
int array[3][5]{};
```

### 二维数组与循环
对于一维数组，可用单循环遍历所有元素：
```
#include <iostream>

int main()
{
    int arr[]{ 1, 2, 3, 4, 5 };

    // 带索引的for循环
    for (std::size_t i{0}; i < std::size(arr); ++i)
        std::cout << arr[i] << ' ';

    std::cout << '\n';

    // 基于范围的for循环
    for (auto e: arr)
        std::cout << e << ' ';

    std::cout << '\n';

    return 0;
}
```
对于二维数组，需要两个循环：一个选择行，另一个选择列。

使用双循环时需确定外层与内层循环。按内存布局顺序访问元素最高效。因C++采用行优先顺序，行选择器应为外层循环，列选择器应为内层循环。
```
#include <iostream>

int main()
{
    int arr[3][4]{ 
        { 1, 2, 3, 4 },
        { 5, 6, 7, 8 },
        { 9, 10, 11, 12 }};

    // 双索引for循环
    for (std::size_t row{0}; row < std::size(arr); ++row) // std::size(arr)返回行数
    {
        for (std::size_t col{0}; col < std::size(arr[0]); ++col) // std::size(arr[0])返回列数
            std::cout << arr[row][col] << ' ';

        std::cout << '\n';
    }

    // 双范围for循环
    for (const auto& arow: arr)   // 获取每行数组
    {
        for (const auto& e: arow) // 获取行内每个元素
            std::cout << e << ' ';

        std::cout << '\n';
    }

    return 0;
}
```

### 二维数组示例
观察二维数组的实际示例：
```
#include <iostream>

int main()
{
    constexpr int numRows{ 10 };
    constexpr int numCols{ 10 };

    // 声明10x10数组
    int product[numRows][numCols]{};

    // 计算乘法表
    // 因乘以0恒为0，无需计算第0行和第0列
    for (std::size_t row{ 1 }; row < numRows; ++row)
    {
        for (std::size_t col{ 1 }; col < numCols; ++col)
        {
            product[row][col] = static_cast<int>(row * col);
        }
     }

    for (std::size_t row{ 1 }; row < numRows; ++row)
    {
        for (std::size_t col{ 1 }; col < numCols; ++col)
        {
            std::cout << product[row][col] << '\t';
        }

        std::cout << '\n';
     }

    return 0;
}
```
此程序计算并打印1到9（含）之间的乘法表。注意打印时循环从1开始而非0，以跳过全为0的第0行和第0列。输出如下：
```
1    2    3    4    5    6    7    8    9
2    4    6    8    10   12   14   16   18
3    6    9    12   15   18   21   24   27
4    8    12   16   20   24   28   32   36
5    10   15   20   25   30   35   40   45
6    12   18   24   30   36   42   48   54
7    14   21   28   35   42   49   56   63
8    16   24   32   40   48   56   64   72
9    18   27   36   45   54   63   72   81
```

### 笛卡尔坐标 vs 数组索引
几何学中常用[笛卡尔坐标系（Cartesian coordinate system）](https://en.wikipedia.org/wiki/Cartesian_coordinate_system)描述物体位置。二维中有两条坐标轴，通常命名为"x"（水平轴）和"y"（垂直轴）。

现在观察C++中的二维数组布局：
```
// 列0    列1    列2    列3    列4
// [0][0] [0][1] [0][2] [0][3] [0][4]  行0
// [1][0] [1][1] [1][2] [1][3] [1][4]  行1
// [2][0] [2][1] [2][2] [2][3] [2][4]  行2
```
这也是二维坐标系，元素位置可描述为[行][列]（列轴方向相反）。

虽然各坐标系本身易于理解，但将笛卡尔坐标{x, y}转换为数组索引[行][列]有违直觉。

关键点在于：笛卡尔系统中的x坐标描述数组索引中选择的*列*，而y坐标描述选择的*行*。因此笛卡尔坐标{x, y}对应数组坐标[y][x]，与预期相反！

这导致二维循环呈现如下形式：
```
    for (std::size_t y{0}; y < std::size(arr); ++y) // 外层循环为行/y
    {
        for (std::size_t x{0}; x < std::size(arr[0]); ++x) // 内层循环为列/x
            std::cout << arr[y][x] << ' '; // 先用y（行）索引，再用x（列）
```
注意此时数组索引为`a[y][x]`，可能与字母顺序预期相反。

[下一课 17.13 — 多维std::array](Chapter-17/lesson17.13-multidimensional-stdarray.md)
[返回主页](/)  
[上一课 17.11 — C风格字符串字面量](Chapter-17/lesson17.11-c-style-string-symbolic-constants.md)