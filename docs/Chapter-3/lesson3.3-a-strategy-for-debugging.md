3.3 — 调试策略  
===============================

[*Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2024年10月18日（首次发布于2019年2月1日）  

在调试程序时，大部分时间通常消耗在定位实际错误的位置。一旦发现问题，修复错误与验证修复的过程相比之下往往较为简单。本章我们将探讨如何定位错误。  

通过代码审查发现问题  
----------------  

假设您注意到某个问题，并希望追踪其根源。在许多情况下（尤其是小型程序中），我们可以基于错误性质与程序结构来推测问题可能的位置。  

考虑以下程序片段：  
```cpp
int main()
{
    getNames(); // 让用户输入一组名字
    sortNames(); // 按字母顺序排序
    printNames(); // 打印排序后的名单

    return 0;
}
```  

若期望程序按字母顺序输出，但实际输出顺序相反，问题很可能出现在*sortNames*函数中。若能将问题缩小到特定函数，通过代码审查可能直接发现问题。  

但随着程序复杂度提升，代码审查的难度也随之增加：  
* 代码量激增：审查数千行代码耗时且枯燥  
* 代码复杂度提高：潜在错误点增多  
* 程序行为缺乏线索：若股票推荐程序无输出，难以确定排查起点  
* 错误假设导致的漏洞：审查时可能重复相同错误假设，难以察觉  

若无法通过代码审查发现问题，如何定位？  

通过运行程序发现问题  
----------------  

当代码审查无效时，可通过观察程序运行时的行为来诊断问题，通用策略如下：  
1. 确定如何重现问题  
2. 运行程序并收集信息以缩小问题范围  
3. 重复上述步骤直至定位问题  

本章后续将讨论支持此策略的技术手段。  

重现问题  
----------------  

调试的首要步骤是能够**重现问题（reproduce the problem）**，即通过一致方式使问题复现。原因很简单：除非观察到问题发生，否则极难定位。  

以制冰机为例：若朋友告知机器故障，但您检查时工作正常，则难以诊断。但若能亲眼见证故障，诊断效率将大幅提升。  

明显问题（如程序每次运行到相同位置崩溃）的重现较为简单。但某些情况下（如问题仅特定计算机或输入条件下出现），建立**重现步骤（reproduction steps）**十分必要。这些步骤应清晰精确，能高概率复现问题。理想情况下应100%复现，50%复现率意味着需要双倍诊断时间。  

缩小问题范围  
----------------  

成功重现问题后，需定位代码中的问题位置。根据问题性质，难度各有不同。假设我们毫无头绪，如何排查？  

以**高低猜数游戏（hi-lo）**类比：您需猜测1-10之间的数字，每次猜测将获得"过高"、"过低"或"正确"的反馈。通过合理猜测与信息分析，可在有限次数内定位正确数字（优化策略最多4次）。  

调试程序可采取类似策略。最坏情况下虽无头绪，但已知问题必出现在程序开始执行到首个可观测错误症状之间的代码中。这排除了首个症状后的代码，但仍需覆盖大量代码。  

初始猜测常基于问题现象：  
* 若程序未按要求写入文件，问题可能在文件写入相关代码  
* 若程序在固定位置崩溃，且某执行点未崩溃，则崩溃必发生在后续代码中  
* 若变量x预期值为2但实际输出8，且某执行点已发现x=8，则问题必发生在此点之前  

通过多次合理猜测与有效技术手段，最终可精确定位问题代码行。排除其他可能后，剩余代码即为问题根源。  

具体策略因错误类型而异，需结合经验与直觉选择。后续章节将介绍基础调试技巧，并逐步扩展方法体系。  

[下一课 3.4 基础调试技巧](Chapter-3/lesson3.4-basic-debugging-tactics.md)  
[返回主页](/)  
[上一课 3.2 调试流程](Chapter-3/lesson3.2-the-debugging-process.md)