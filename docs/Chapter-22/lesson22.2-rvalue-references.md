22.2 — 右值引用  
===========================  

[*作者：Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2024年5月15日（首次发布于2017年2月20日）  

 

在第12章中，我们介绍了值类别（value categories）的概念（[12.2 — 值类别（左值与右值）](Chapter-12/lesson12.2-value-categories-lvalues-and-rvalues.md)），这是表达式的属性，用于确定表达式解析为值、函数还是对象。我们还引入了左值（l-value）和右值（r-value）以便讨论左值引用。  

如果您对左值和右值概念模糊，现在是复习的好时机，因为本章将大量涉及这些概念。  

左值引用回顾  
----------------  

在C++11之前，C++中只存在一种引用类型，因此直接称为"引用"。但在C++11中，它被明确称为左值引用（l-value reference）。左值引用只能用可修改左值进行初始化。  

| 左值引用         | 可被初始化为         | 可修改性        |  
|-------------------|-----------------------|-----------------|  
| 可修改左值        | 是                   | 是              |  
| 不可修改左值      | 否                   | 否              |  
| 右值              | 否                   | 否              |  

指向常量对象的左值引用可以用可修改左值、不可修改左值和右值进行初始化，但这些值不能被修改。  

| 常量左值引用       | 可被初始化为         | 可修改性        |  
|-------------------|-----------------------|-----------------|  
| 可修改左值        | 是                   | 否              |  
| 不可修改左值      | 是                   | 否              |  
| 右值              | 是                   | 否              |  

指向常量对象的左值引用特别有用，因为它们允许我们将任何类型的参数（左值或右值）传递给函数而无需复制参数。  

右值引用  
----------------  

C++11新增了称为右值引用（r-value reference）的引用类型。右值引用是专门用于初始化右值的引用。左值引用使用单&符号创建，右值引用使用双&符号创建：  

```cpp  
int x{5};  
int& lref{x};   // 左值引用用左值x初始化  
int&& rref{5};  // 右值引用用右值5初始化  
```  

右值引用不能用左值初始化。  

| 右值引用         | 可被初始化为         | 可修改性        |  
|-------------------|-----------------------|-----------------|  
| 可修改左值        | 否                   | 否              |  
| 不可修改左值      | 否                   | 否              |  
| 右值              | 是                   | 是              |  

| 常量右值引用       | 可被初始化为         | 可修改性        |  
|-------------------|-----------------------|-----------------|  
| 可修改左值        | 否                   | 否              |  
| 不可修改左值      | 否                   | 否              |  
| 右值              | 是                   | 否              |  

右值引用有两个实用特性：首先，右值引用会将其初始化对象的生命周期延长至引用本身的生命周期（指向常量对象的左值引用也有此特性）；其次，非常量右值引用允许修改右值！  

示例分析：  

```cpp  
#include <iostream>  

class Fraction  
{  
private:  
    int m_numerator{0};  
    int m_denominator{1};  

public:  
    Fraction(int numerator = 0, int denominator = 1)  
        : m_numerator{numerator}, m_denominator{denominator}  
    {  
    }  

    friend std::ostream& operator<<(std::ostream& out, const Fraction& f1)  
    {  
        out << f1.m_numerator << '/' << f1.m_denominator;  
        return out;  
    }  
};  

int main()  
{  
    auto&& rref{Fraction{3, 5}}; // 右值引用指向临时Fraction对象  

    // operator<<的f1参数绑定到临时对象，不会创建副本  
    std::cout << rref << '\n';  

    return 0;  
} // rref（及临时Fraction）在此处离开作用域  
```  

该程序输出：  

```  
3/5  
```  

作为匿名对象，Fraction(3, 5)通常会在定义它的表达式结束时离开作用域。但由于我们用右值引用初始化它，其生命周期将延长至代码块结束。  

再看另一个示例：  

```cpp  
#include <iostream>  

int main()  
{  
    int&& rref{5}; // 用字面量初始化右值引用，此处创建值为5的临时对象  
    rref = 10;  
    std::cout << rref << '\n';  

    return 0;  
}  
```  

程序输出：  

```  
10  
```  

虽然用字面量初始化右值引用后修改该值看似奇怪，但当使用字面量初始化右值引用时，会从字面量构造临时对象，因此引用指向的是临时对象而非字面量。  

右值引用作为函数参数  
----------------  

右值引用更常用于函数参数。当需要为左值和右值参数提供不同行为时，函数重载特别有用。  

```cpp  
#include <iostream>  

void fun(const int& lref) // 左值参数选择此函数  
{  
    std::cout << "左值引用转常量：" << lref << '\n';  
}  

void fun(int&& rref) // 右值参数选择此函数  
{  
    std::cout << "右值引用：" << rref << '\n';  
}  

int main()  
{  
    int x{5};  
    fun(x);  // 左值参数调用左值版本  
    fun(5);  // 右值参数调用右值版本  

    return 0;  
}  
```  

输出：  

```  
左值引用转常量：5  
右值引用：5  
```  

当传递左值时，重载函数解析到左值引用版本；传递右值时，解析到右值引用版本（这比常量左值引用更匹配）。  

右值引用变量是左值  
----------------  

考虑以下代码片段：  

```cpp  
int&& ref{5};  
fun(ref);  
```  

这里会调用哪个版本的`fun`？答案是`fun(const int&)`。  

虽然变量`ref`的类型是`int&&`，但在表达式中使用时它是左值（所有命名变量都是左值）。对象的类型与其值类别是独立的。  

返回右值引用  
----------------  

应当避免返回右值引用，原因与避免返回左值引用相同——当引用对象在函数结束时离开作用域，可能导致悬垂引用。  

测验时间  
----------------  

**问题1**  
指出以下代码中哪些字母标记的语句无法编译：  

```cpp  
int main()  
{  
    int x{};  

    // 左值引用  
    int& ref1{x};    // A  
    int& ref2{5};    // B  

    const int& ref3{x}; // C  
    const int& ref4{5}; // D  

    // 右值引用  
    int&& ref5{x};   // E  
    int&& ref6{5};   // F  

    const int&& ref7{x}; // G  
    const int&& ref8{5}; // H  

    return 0;  
}  
```  

  
<details><summary>答案</summary>B、E、G无法编译。</details>  

绑定规则总结：  
* 非常量左值引用只能绑定到非常量左值  
* 常量左值引用可绑定到非常量左值、常量左值和右值  
* 右值引用只能绑定到右值  

`x`是非常量左值，因此可以绑定非常量左值引用（A）和常量左值引用（C）。`5`是右值，可以绑定常量左值引用（D）和右值引用（F & H）。不能将右值引用绑定到左值（E & G）。  

[下一课 22.3 移动构造函数与移动赋值](Chapter-22/lesson22.3-move-constructors-and-move-assignment.md)  
[返回主页](/)  
[上一课 22.1 智能指针与移动语义简介](Chapter-22/lesson22.1-introduction-to-smart-pointers-move-semantics.md)