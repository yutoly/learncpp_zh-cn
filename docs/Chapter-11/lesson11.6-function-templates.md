11.6 — 函数模板（Function Templates）
================================================

[*作者：Alex*](https://www.learncpp.com/author/Alex/ "查看 Alex 的所有文章")  
2025年1月27日（首次发布于2008年4月18日）  

假设您想编写一个求两数最大值的函数，可能实现如下：
```cpp
int max(int x, int y)
{
    return (x < y) ? y : x;
    // 注意：此处使用<而非>，因为std::max也使用<
}
```
虽然调用者可以传递不同值，但参数类型固定，因此只能传入`int`类型。这意味着该函数仅适用于整数（及可隐式转换为`int`的类型）。  

当需要求两个`double`值的最大值时，由于C++要求指定所有函数参数类型，解决方案是为`max`创建`double`类型的重载版本：
```cpp
double max(double x, double y)
{
    return (x < y) ? y : x;
}
```
注意`double`版`max`的实现代码与`int`版完全相同！实际上，这种实现适用于多种类型：`int`、`double`、`long`、`long double`，甚至包括自定义类型（后续课程介绍）。  

为每种参数类型创建重载函数会导致维护困难、错误风险，并明显违反DRY（不要重复自己）原则。还存在隐性问题：用户可能使用`max`作者未预见的参数类型调用该函数（因此未编写对应重载）。  

我们需要一种能编写适用于任何类型的单一`max`版本的方法（包括编写`max`时未预见的类型）。普通函数无法满足此需求，C++为此提供了专门解决方案——模板。  

C++模板简介  
----------------  

模板系统旨在简化创建可处理不同数据类型的函数（或类）的过程。通过创建单个**模板（template）**代替大量相似函数/类，模板使用**占位符类型（placeholder type）**表示编写时未知但后续提供的类型。编译器根据模板生成所需重载函数/类。  

关键洞察  
> 编译器能用单个模板生成一系列相关函数/类，每个使用不同的实际类型集合。  

类比说明  
> 模板如同创建相似对象的模具。例如镂空模板（stencil）可快速复制形状，模板本身只需创建一次，之后可重复使用。类似地，C++模板允许我们定义函数/类的"模具"，使用时填充具体类型。  

关键洞察  
> 模板可使用编写时尚未存在的类型，这使得模板代码既灵活又具有前瞻性。  

函数模板  
----------------  

**函数模板（function template）**是生成多个重载函数的类函数定义。用于生成其他函数的初始模板称为**主模板（primary template）**，生成的函数称为**实例化函数（instantiated function）**。  

在主函数模板中，使用**占位符类型（placeholder type）**（正式称**类型模板参数（type template parameter）**，俗称**模板类型**）代替需要用户后续指定的参数类型、返回类型或函数体内使用的类型。  

高级知识  
> C++支持三种模板参数：  
> * 类型模板参数（表示类型）  
> * 非类型模板参数（表示constexpr值）  
> * 模板模板参数（表示模板）  

类型模板参数最常见，本节重点讨论。现代C++中非类型模板参数使用也在增加。  

创建`max()`函数模板  
----------------  

将普通`max(int, int)`函数转换为模板：  

原`int`版本：
```cpp
int max(int x, int y)
{
    return (x < y) ? y : x;
}
```
将需要替换的`int`类型改为类型模板参数`T`：
```cpp
template <typename T> // 模板参数声明，定义T为类型模板参数
T max(T x, T y)       // 函数模板max<T>的定义
{
    return (x < y) ? y : x;
}
```
模板参数声明以`template`关键字开头，尖括号`<>`内指定所有模板参数。每个类型模板参数使用`typename`（推荐）或`class`关键字，后跟参数名（如`T`）。  

相关链接  
> 多模板类型函数模板详见课程[11.8 — 多模板类型的函数模板](Chapter-11/lesson11.8-function-templates-with-multiple-template-types.md)  

补充说明  
> 此处`typename`与`class`无区别。早期多用`class`，但推荐`typename`以明确参数可以是基础类型。  

模板参数命名  
----------------  

常规情况下，使用以`T`开头的单个大写字母命名模板参数（如`T`、`U`、`V`）。对于非直观或特定要求的类型参数，常用两种命名约定：  
1. 首字母大写（如`Allocator`），标准库采用此方式  
2. 前缀`T`加大写（如`TAllocator`），便于识别模板参数  

最佳实践  
> 对通用"合理类型"使用`T`等单字母命名，对特殊要求的类型使用描述性名称。  

高级示例  
> 标准库`std::max()`的一个重载声明：
> ```cpp
> template< class T, class Compare >
> const T& max( const T& a, const T& b, Compare comp ); // 忽略&，后续课程讲解
> ```
> `a`和`b`为`T`类型，`comp`需满足`Compare`类型要求。实例化时，编译器根据类型使用方式推断要求，建议查阅文档明确需求。  

测验时间  
----------------  

**问题1**  
为什么建筑蓝图属于模板类型？  
  
<details><summary>答案</summary>蓝图描述建筑结构，施工队可根据蓝图快速建造结构相同的建筑。具体材料类型可在建造时确定。</details>  

[下一课 11.7 函数模板实例化](Chapter-11/lesson11.7-function-template-instantiation.md)  
[返回主页](/)  
[上一课 11.5 默认参数](Chapter-11/lesson11.5-default-arguments.md)